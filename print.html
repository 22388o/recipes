<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Substrate Recipes</title>
        
        <meta name="robots" content="noindex" />
        

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="A Hands-On Cookbook for Aspiring Blockchain Chefs">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "light" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div id="sidebar-scrollbox" class="sidebar-scrollbox">
                <ol class="chapter"><li class="expanded affix "><a href="introduction.html">Introduction</a></li><li class="expanded "><a href="1-prepare-kitchen/index.html"><strong aria-hidden="true">1.</strong> Preparing Your Kitchen</a></li><li><ol class="section"><li class="expanded "><a href="1-prepare-kitchen/1-build-node.html"><strong aria-hidden="true">1.1.</strong> Building A Node</a></li><li class="expanded "><a href="1-prepare-kitchen/2-interact-node.html"><strong aria-hidden="true">1.2.</strong> Interacting with a Node</a></li><li class="expanded "><a href="1-prepare-kitchen/3-kitchen-organization.html"><strong aria-hidden="true">1.3.</strong> Kitchen Organization</a></li></ol></li><li class="expanded "><a href="2-appetizers/index.html"><strong aria-hidden="true">2.</strong> Appetizers</a></li><li><ol class="section"><li class="expanded "><a href="2-appetizers/1-hello-substrate.html"><strong aria-hidden="true">2.1.</strong> Hello Substrate</a></li><li class="expanded "><a href="2-appetizers/2-storage-values.html"><strong aria-hidden="true">2.2.</strong> Single Value Storage</a></li><li class="expanded "><a href="2-appetizers/3-errors.html"><strong aria-hidden="true">2.3.</strong> Handling Errors</a></li><li class="expanded "><a href="2-appetizers/4-events.html"><strong aria-hidden="true">2.4.</strong> Events Verify Execution</a></li></ol></li><li class="expanded "><a href="3-entrees/index.html"><strong aria-hidden="true">3.</strong> Entrees</a></li><li><ol class="section"><li class="expanded "><a href="3-entrees/storage-api/index.html"><strong aria-hidden="true">3.1.</strong> Runtime Storage API</a></li><li><ol class="section"><li class="expanded "><a href="3-entrees/storage-api/cache.html"><strong aria-hidden="true">3.1.1.</strong> Cache Locally &gt; Storage Calls</a></li><li class="expanded "><a href="3-entrees/storage-api/iterate.html"><strong aria-hidden="true">3.1.2.</strong> Sets</a></li><li class="expanded "><a href="3-entrees/storage-api/enumerated.html"><strong aria-hidden="true">3.1.3.</strong> Ordered Lists: Maps, Linked Maps</a></li><li class="expanded "><a href="3-entrees/storage-api/double.html"><strong aria-hidden="true">3.1.4.</strong> Subgroup Removal by Subkey: Double Maps</a></li><li class="expanded "><a href="3-entrees/storage-api/childtries.html"><strong aria-hidden="true">3.1.5.</strong> Efficient Subgroup Removal by Subkey: Child Tries</a></li><li class="expanded "><a href="3-entrees/storage-api/structs.html"><strong aria-hidden="true">3.1.6.</strong> Storing custom structs</a></li></ol></li><li class="expanded "><a href="3-entrees/basic-token.html"><strong aria-hidden="true">3.2.</strong> Basic Token</a></li><li class="expanded "><a href="3-entrees/constants.html"><strong aria-hidden="true">3.3.</strong> Configurable Constants</a></li><li class="expanded "><a href="3-entrees/instantiable.html"><strong aria-hidden="true">3.4.</strong> Instantiable Pallets</a></li><li class="expanded "><a href="3-entrees/weights.html"><strong aria-hidden="true">3.5.</strong> Weights for Resource Accounting</a></li><li class="expanded "><a href="3-entrees/fees.html"><strong aria-hidden="true">3.6.</strong> Transaction Fees for Economic Security</a></li><li class="expanded "><a href="3-entrees/charity.html"><strong aria-hidden="true">3.7.</strong> Charity and Imbalances</a></li><li class="expanded "><a href="3-entrees/runtime-api.html"><strong aria-hidden="true">3.8.</strong> Runtime APIs</a></li><li class="expanded "><a href="3-entrees/custom-rpc.html"><strong aria-hidden="true">3.9.</strong> Custom RPCs</a></li><li class="expanded "><a href="3-entrees/currency.html"><strong aria-hidden="true">3.10.</strong> Currency Types</a></li><li class="expanded "><a href="3-entrees/random.html"><strong aria-hidden="true">3.11.</strong> Generating Randomness</a></li><li class="expanded "><a href="3-entrees/execution-schedule.html"><strong aria-hidden="true">3.12.</strong> Execution Schedule</a></li><li class="expanded "><a href="3-entrees/permissioned-methods.html"><strong aria-hidden="true">3.13.</strong> Permissioned Methods</a></li><li class="expanded "><a href="3-entrees/testing/index.html"><strong aria-hidden="true">3.14.</strong> Testing</a></li><li><ol class="section"><li class="expanded "><a href="3-entrees/testing/mock.html"><strong aria-hidden="true">3.14.1.</strong> Basic Test Environments</a></li><li class="expanded "><a href="3-entrees/testing/common.html"><strong aria-hidden="true">3.14.2.</strong> Common Tests</a></li><li class="expanded "><a href="3-entrees/testing/externalities.html"><strong aria-hidden="true">3.14.3.</strong> Custom Test Environment</a></li></ol></li><li class="expanded "><a href="3-entrees/safemath.html"><strong aria-hidden="true">3.15.</strong> Safe Math</a></li><li class="spacer"></li></ol></li><li class="expanded "><a href="more-resources.html">More Resources</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar" class="menu-bar">
                    <div id="menu-bar-sticky-container">
                        <div class="left-buttons">
                            <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                                <i class="fa fa-bars"></i>
                            </button>
                            <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                                <i class="fa fa-paint-brush"></i>
                            </button>
                            <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                                <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                            </ul>
                            
                            <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                                <i class="fa fa-search"></i>
                            </button>
                            
                        </div>

                        <h1 class="menu-title">Substrate Recipes</h1>

                        <div class="right-buttons">
                            <a href="print.html" title="Print this book" aria-label="Print this book">
                                <i id="print-button" class="fa fa-print"></i>
                            </a>
                            
                        </div>
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1><a class="header" href="#substrate-recipes-" id="substrate-recipes-">Substrate Recipes 🍴😋🍴</a></h1>
<p><em>A Hands-On Cookbook for Aspiring Blockchain Chefs</em></p>
<p>Substrate Recipes is a cookbook of working examples that demonstrate best practices when building blockchains with <strong><a href="https://github.com/paritytech/substrate">Substrate</a></strong>. Each recipe contains a complete working code example as well as a detailed writeup describing the code. This book is <a href="https://github.com/substrate-developer-hub/recipes">open source</a>. Check out the <a href="https://github.com/substrate-developer-hub/recipes/blob/master/CONTRIBUTING.md">contributing guidelines</a> for an overview of the structure and directions for getting involved.</p>
<h2><a class="header" href="#how-to-use-this-book" id="how-to-use-this-book">How to Use This Book</a></h2>
<p>The easiest place to read this book is at <a href="https://substrate.dev/recipes">https://substrate.dev/recipes</a>.</p>
<p>The first two chapters are meant to be read in order.</p>
<p>In Chapter 1, <a href="./1-prepare-kitchen/index.html">Preparing your Kitchen</a>, you will set up your toolchain, compile a blockchain node, and learn to interact with the blockchain.</p>
<p>In Chapter 2, <a href="./2-appetizers/index.html">Appetizers</a>, you will cook your first few recipes, learning the fundamentals of Substrate development.</p>
<p>The rest of the book, the &quot;Entrees&quot;, can be read in any order, and you should skip to whichever recipes interest you.</p>
<p>Remember, you can't learn to cook by reading alone. As you work through the book, put on your apron, get out some pots and pans, and practice compiling, testing, and hacking on the recipes. Play with the code in the kitchen, extract patterns, and apply them to a problem that you want to solve!</p>
<h2><a class="header" href="#getting-help" id="getting-help">Getting Help</a></h2>
<p>When learning any new skill, you will inevitably get stuck at some point. When you do get stuck you can seek help in several ways:</p>
<ul>
<li>Ask a question on <a href="https://stackoverflow.com/questions/tagged/substrate">Stack Overflow</a></li>
<li>Ask a question in the <a href="https://riot.im/app/#/room/#substrate-technical:matrix.org">Substrate Technical Riot channel</a></li>
<li>Open a <a href="https://github.com/substrate-developer-hub/recipes/issues/new">new issue</a> against this repository</li>
</ul>
<h2><a class="header" href="#what-is-substrate" id="what-is-substrate">What is Substrate?</a></h2>
<p><a href="https://github.com/paritytech/substrate">Substrate</a> is a framework for building blockchains. For a high level overview, read the following blog posts:</p>
<ul>
<li><a href="https://www.parity.io/what-is-substrate/">What is Substrate?</a></li>
<li><a href="https://www.parity.io/substrate-in-a-nutshell/">Substrate in a nutshell</a></li>
<li><a href="https://www.parity.io/a-brief-summary-of-everything-substrate-polkadot/">A brief summary of everything Substrate and Polkadot</a></li>
</ul>
<p>To learn more about Substrate, see the <a href="https://substrate.dev">official documentation</a>.</p>
<h2><a class="header" href="#learning-rust" id="learning-rust">Learning Rust</a></h2>
<p>Becoming productive with Substrate requires some familiarity with Rust. Fortunately, the Rust community is known for comprehensive documentation and tutorials. The most common resource for initially learning Rust is <a href="https://doc.rust-lang.org/book/index.html">The Rust Book</a>. To see examples of popular crate usage patterns, <a href="https://doc.rust-lang.org/rust-by-example/index.html">Rust by Example</a> is also convenient.</p>
<p>While knowing some Rust is certainly necessary, it is not wise to delay learning Substrate until you are a Rust guru. Rather than learning Rust <em>before</em> you learn Substrate, consider learning Rust <em>as</em> you learn Substrate. If you're beyond the fundamentals of Rust, there are lots <a href="./more-resources.html">more Rust resources</a> at the end of the book.</p>
<h1><a class="header" href="#setting-up-your-kitchen" id="setting-up-your-kitchen">Setting Up Your Kitchen</a></h1>
<p>Any experienced chef will tell you that cooking delicious blockchains... I mean meals... starts with a properly equipped and organized kitchen. In this chapter we will guide you through setting up your development environment, and introduce you to the structure of the recipes repository.</p>
<p>This section covers:</p>
<ul>
<li><a href="1-prepare-kitchen/./1-build-node.html">Building a Node</a> - Compile and execute your first Substrate-based blockchain node.</li>
<li><a href="1-prepare-kitchen/./2-interact-node.html">Interacting with the Node</a> - Submit transactions and inspect state with a user interface.</li>
<li><a href="1-prepare-kitchen/./3-kitchen-organization.html">Understanding the Kitchen's Organization</a> - How is the code organized, and why?</li>
</ul>
<h1><a class="header" href="#building-a-node" id="building-a-node">Building a Node</a></h1>
<h2><a class="header" href="#prerequisites" id="prerequisites">Prerequisites</a></h2>
<p>Before we can even begin compiling our first blockchain node, we need to have a properly configured Rust toolchain. There is a convenient script that will set up this toolchain for us, and we can run it with the following command.</p>
<pre><code class="language-bash"># Setup Rust and Substrate
curl https://getsubstrate.io -sSf | bash -s -- --fast
</code></pre>
<blockquote>
<p>This command downloads and executes code from the internet. Give yourself peace-of-mind by inspecting the <a href="https://getsubstrate.io">script's source</a> to confirm it isn't doing anything nasty.</p>
</blockquote>
<h3><a class="header" href="#for-windows" id="for-windows">For Windows</a></h3>
<p>These instructions and the rest of the instructions in this chapter assume a unix-like environment such as Linux, MacOS, or Windows Subsystem for Linux (WSL). If you are a Windows user, WSL is the best way to proceed. If you want or need to work in a native Windows environment, this is possible, but is not covered in detail here. Please follow along with the <a href="https://substrate.dev/docs/en/overview/getting-started#getting-started-on-windows">Getting Started on Windows</a> guide, then return here when you're ready to proceed.</p>
<h2><a class="header" href="#compile-the-kitchen-node" id="compile-the-kitchen-node">Compile the Kitchen Node</a></h2>
<p>If you haven't already, <code>git clone</code> the recipes repository. We also want to kick-start the node compilation as it may take about 30 minutes to complete depending on your hardware.</p>
<pre><code class="language-bash"># Clone the Recipes Repository
git clone https://github.com/substrate-developer-hub/recipes.git
cd recipes

#  Update Rust-Wasm toolchain
./nodes/scripts/init.sh

# Compile the Kitchen Node
# This step takes a while to complete
cargo build --release -p kitchen-node
</code></pre>
<p>As you work through the recipes, refer back to these instructions each time you wish to re-compile the node. Over time the commands will become familiar, and you will even modify them to compile other nodes.</p>
<h2><a class="header" href="#checking-your-work" id="checking-your-work">Checking Your Work</a></h2>
<p>Once the compilation is completed, you can ensure that the node has built properly by displaying its help page. Notice that the node has built to the <code>target/release</code> directory. This is the default location for Rust projects.</p>
<pre><code class="language-bash"># Inside `recipes` directory

# Display the Kitchen Node's help page
./target/release/kitchen-node --help
</code></pre>
<h1><a class="header" href="#interact-with-the-kitchen-node" id="interact-with-the-kitchen-node">Interact with the Kitchen Node</a></h1>
<p>If you followed the instructions to <a href="1-prepare-kitchen/./1-build-node.html">build the node</a>, you my proceed to launch your first blockchain.</p>
<h2><a class="header" href="#launch-a-development-node" id="launch-a-development-node">Launch a Development Node</a></h2>
<p>Before we launch our node we will purge any chain data. If you've followed the instructions exactly, you will not yet have any chain data to purge, but on each subsequent run, you will, and it is best to get in the habbit of purging your chain now. We will start our node in development mode (<code>--dev</code>).</p>
<pre><code class="language-bash"># Purge existing blockchain data (if any)
./target/release/kitchen-node purge-chain --dev

# Start a fresh development blockchain
./target/release/kitchen-node --dev
</code></pre>
<p>You should now see blocks created on the console.</p>
<h2><a class="header" href="#launch-the-apps-user-interface" id="launch-the-apps-user-interface">Launch the Apps User Interface</a></h2>
<p>You can navigate to the  <a href="https://polkadot.js.org/apps/#/settings/developer?rpc=ws://127.0.0.1:9944">Polkadot-JS Apps</a> user interface. This is a general purpose interface for interacting with many different Substrate-based blockchains including Polkadot. From now on we'll call it &quot;Apps&quot; for short. Before Apps will work with our blockchain, we need to give it a little chain-specific information known as the &quot;types&quot;. You'll learn what all this means as you work through the recipes; for now just follow the instructions.</p>
<blockquote>
<p>If you are not clicking the link above but visiting Apps directly, by default Apps connects to Polkadot Kusama network. You will need to switch the connecting network to your locally running network, with only one node, by clicking on the network icon on Apps top left corner.</p>
<p><img src="1-prepare-kitchen/../img/apps-select-network.png" alt="Screenshot: Switching Network" /></p>
</blockquote>
<blockquote>
<p>Some browsers, notably Firefox, will not connect to a local node from an https website. An easy work around is to try another browser, like Chromium. Another option is to <a href="https://github.com/polkadot-js/apps#development">host this interface locally</a>.</p>
</blockquote>
<p>If you're not already on the <code>Settings -&gt; Developer</code>page, please navigate there. Copy the contents of <code>runtimes/super-runtime/types.json</code> into Apps.</p>
<p><img src="1-prepare-kitchen/../img/apps-types.png" alt="Screenshot: pasting types into Apps UI" /></p>
<p>As you work through the recipes, you will use the <strong>Chain State</strong> tab to query the blockchain status and <strong>Extrinsics</strong> to send transactions to the blockchain. Play around for a bit before moving on.</p>
<h1><a class="header" href="#kitchen-organization" id="kitchen-organization">Kitchen Organization</a></h1>
<p>Now that your kitchen is well-equipped with all the right tools (bowls, knives, Rust compiler, etc), let's take a look at how it is organized.</p>
<h2><a class="header" href="#structure-of-a-substrate-node" id="structure-of-a-substrate-node">Structure of a Substrate Node</a></h2>
<p>It is useful to recognize that <a href="https://youtu.be/05H4YsyPA-U?t=1789">coding is all about abstraction</a>.</p>
<p>To understand how the code in this repository is organized, let's first take a look at how a Substrate node is constructed. Each node has many components that manage things like queueing transaction, communicating over a P2P network, reaching consensus on the state of the blockchain, and the chain's actual runtime logic. Each aspect of the node is interesting in its own right, and the runtime is particularly interesting because it contains the business logic (aka &quot;state transition function&quot;) that codifies the chain's functionality.</p>
<p>Much, but not all, of the Recipes focuses on writing runtimes with FRAME, Parity's Framework for composing runtimes from individual building blocks called Pallets. Runtimes built with FRAME typically contain several such pallets. The kitchen node you built previously follows this paradigm.</p>
<ul>
<li>Blockchain Node
<ul>
<li>P2P Messaging</li>
<li>Consensus</li>
<li>Runtime
<ul>
<li>Pallet 1</li>
<li>Pallet 2</li>
<li>Pallet 3</li>
</ul>
</li>
<li>Transaction Queue</li>
<li>RPC</li>
</ul>
</li>
</ul>
<h2><a class="header" href="#the-directories-in-our-kitchen" id="the-directories-in-our-kitchen">The Directories in our Kitchen</a></h2>
<p>There are four primary directories in this repository:</p>
<ul>
<li><strong>Text</strong>: Source of <a href="https://substrate.dev/recipes">the book</a> written in markdown. This is what you're reading right now.</li>
<li><strong>Nodes</strong>: Complete Substrate nodes ready to run.</li>
<li><strong>Runtimes</strong>: Complete runtimes for use in Substrate nodes.</li>
<li><strong>Pallets</strong>: Complete pallets for use in FRAME-based runtimes.</li>
</ul>
<p>Exploring those directories reveals a tree that looks like this</p>
<pre><code>recipes
|
+-- text
|
+-- nodes
	|
	+-- kitchen-node    &lt;-- You built this previously
	|
	+-- rpc-node
|
+-- runtimes
	|
	+-- super-runtime    &lt;-- You built this too (it is part of the kitchen-node)
	|
	+-- super-genesis    &lt;-- You built this too (it is part of the kitchen-node)
	|
	+-- weight-fee-runtime
	|
	+-- weight-fee-genesis
	|
	+ ...
|
+-- pallets
	|
	+-- adding-machine    &lt;-- You built this too (it is part of super-runtime)
	|
	+-- basic-token        &lt;-- You built this too (it is part of super-runtime)
	|
	+ ...
	|
	+-- weights
</code></pre>
<h2><a class="header" href="#inside-the-kitchen-node" id="inside-the-kitchen-node">Inside the Kitchen Node</a></h2>
<p>Let us take a deeper look at the <a href="https://github.com/substrate-developer-hub/recipes/tree/master/nodes/kitchen-node">Kitchen Node</a>.</p>
<p><strong><code>nodes/kitchen-node/Cargo.toml</code></strong></p>
<pre><code class="language-TOML"># -- snip --
runtime = { package = &quot;super-runtime&quot;, path = &quot;../../runtimes/super-runtime&quot; }
runtime-genesis = { package = &quot;super-genesis&quot;, path = &quot;../../runtimes/super-genesis&quot; }
# runtime = { package = &quot;weight-fee-runtime&quot;, path = &quot;../runtimes/weight-fee-runtime&quot;}
# runtime-genesis = { package = &quot;weight-fee-genesis&quot;, path = &quot;../runtimes/weight-fee-genesis&quot;}
</code></pre>
<p>Looking inside the Kitchen Node's <code>Cargo.toml</code> file we see that it has many dependencies. Most of them come from Substrate itself. Indeed most parts of this Kitchen Node are not unique or specialized, and Substrate offers robust implementations that we can use. The lines quoted above show that the runtime does not come from Substrate. Rather, we use our super-runtime which is in the <code>runtimes</code> folder.</p>
<p>The commented lines, also quoted above, show that the Super Runtime is not the only runtime we could have chosen. We could also use the Weight-Fee runtime, and I encourage you to try that experiment (remember, instructions to re-compile the node are in the previous section).</p>
<p>Every node must have a runtime. You may confirm that by looking at the <code>Cago.toml</code> files of the other nodes included in our kitchen.</p>
<h2><a class="header" href="#inside-the-super-runtime" id="inside-the-super-runtime">Inside the Super Runtime</a></h2>
<p>Having seen that the Kitchen Node depends on a runtime, let us now look deeper at the <a href="https://github.com/substrate-developer-hub/recipes/tree/master/runtimes/super-runtime">Super Runtime</a>.</p>
<p><strong><code>runtimes/super-runtime/Cargo.toml</code></strong></p>
<pre><code class="language-TOML"># -- snip --

# Substrate Pallets
balances = { package = 'pallet-balances', git = 'https://github.com/paritytech/substrate.git', ... }
transaction-payment = { package = 'pallet-transaction-payment', git = 'https://github.com/paritytech/substrate.git',... }
# Recipe Pallets
adding-machine = { path = &quot;../../pallets/adding-machine&quot;, default-features = false }
basic-token = { path = &quot;../../pallets/basic-token&quot;, default-features = false }
</code></pre>
<p>Here we see that the runtime depends on many pallets. Some of these pallets come from Substrate itself. Indeed, Substrate offers a rich collection of commonly used pallets which you may use in your own runtimes. This runtime also contains several custom pallets that are written right here in our Kitchen.</p>
<h2><a class="header" href="#common-patterns" id="common-patterns">Common Patterns</a></h2>
<p>We will not yet look closely at individual Pallets. We will begin that endeavor in the next chapter -- Appetizers.</p>
<p>We've just observed the general pattern used throughout the recipes. From the inside out, we see a piece of pallet code stored in <code>pallets/&lt;pallet-name&gt;/src/lib.rs</code>. The pallet is then included into a runtime by adding its name and relative path in <code>runtimes/&lt;runtime-name&gt;/Cargo.toml</code>. that runtime is then installed in a node by adding its name and relative path in <code>nodes/&lt;node-name&gt;/Cargo.toml</code>. Of course adding pallets and runtimes also requires changing actual <em>code</em> as well. We will cover those details in due course. For now we're just focusing on macroscopic relationships between the parts of a Substrate node.</p>
<p>Some recipes explore aspects of Blockchain development that are outside of the runtime. Looking back to our node architecture at the beginning of this section, you can imagine that changing a node's RPC or Consensus would be conceptually similar to changing its runtime.</p>
<h2><a class="header" href="#additional-resources" id="additional-resources">Additional Resources</a></h2>
<p>Substrate Developer Hub offers tutorials that go into more depth about writing pallets and including them in runtimes. If you desire, you may read them as well.</p>
<ul>
<li><a href="https://substrate.dev/docs/en/next/tutorials/creating-a-runtime-module">Creating an External Pallet</a></li>
<li><a href="https://substrate.dev/docs/en/next/tutorials/adding-a-module-to-your-runtime">Adding a Pallet to Your Runtime Tutorial</a></li>
</ul>
<h1><a class="header" href="#lets-get-cooking" id="lets-get-cooking">Let's Get Cooking!</a></h1>
<p>When you're ready, we can begin by cooking some appetizer pallets.</p>
<h1><a class="header" href="#appetizers" id="appetizers">Appetizers</a></h1>
<p>This section of the cookbook will focus on Appetizers, small runtime pallets that teach you the basics of writing pallets with a little hand-holding. If you are brand new to Substrate, you should follow through these appetizers in order. If you've already got the basics of pallet development down, you may skip ahead to the entrees which may be read in any order.</p>
<p>This section covers:</p>
<ul>
<li><a href="2-appetizers/./1-hello-substrate.html">Dispatchable Calls</a> - How users submit transactions</li>
<li><a href="2-appetizers/./2-storage-values.html">Storage Values</a> - Storing the state of the blockchain</li>
<li><a href="2-appetizers/./3-errors.html">Errors</a> - When things go wrong during a transaction</li>
<li><a href="2-appetizers/./4-events.html">Events</a> - Notifying the offchain world of success</li>
</ul>
<h1><a class="header" href="#hello-substrate" id="hello-substrate">Hello Substrate</a></h1>
<p><em><a href="https://github.com/substrate-developer-hub/recipes/tree/master/pallets/hello-substrate"><code>pallets/hello-substrate</code></a></em></p>
<p>The first pallet we'll explore is a simple &quot;hello world&quot; example. This pallet will have one dispatchable call that prints a message to the node's output. Because this is our first pallet, we'll also explore the structure that every pallet has. This code lives in <code>pallets/hello-substrate/src/lib.rs</code>.</p>
<h2><a class="header" href="#no-std" id="no-std">No Std</a></h2>
<p>The very first line of code tells the rust compiler that this crate should not use rust's standard library except when explicitly told to. This is useful because Substrate runtimes compile to Web Assembly where the standard library is not available.</p>
<pre><code class="language-rust ignore">#![cfg_attr(not(feature = &quot;std&quot;), no_std)]
</code></pre>
<h2><a class="header" href="#imports" id="imports">Imports</a></h2>
<p>Next, you'll find imports that come from various parts of the Substrate framework. All pallets will import from a few common crates including <a href="https://substrate.dev/rustdocs/master/frame_support/index.html"><code>frame-support</code></a>, and <a href="https://substrate.dev/rustdocs/master/frame_system/index.html"><code>frame-system</code></a>.  Complex pallets will have many imports as we'll see later. The <code>hello-substrate</code> pallet uses these imports.</p>
<pre><code class="language-rust ignore">use frame_support::{ decl_module, dispatch::DispatchResult };
use frame_system::{ self as system, ensure_signed };
use sp_runtime::print;
</code></pre>
<h2><a class="header" href="#tests" id="tests">Tests</a></h2>
<p>Next we see a reference to the tests module. This pallet has tests written in a separate file called <code>tests.rs</code>. We will not discuss the tests further at this point, but they are covered in the <a href="2-appetizers/../3-entrees/testing/index.html">Testing section</a> of the book.</p>
<h2><a class="header" href="#configuration-trait" id="configuration-trait">Configuration Trait</a></h2>
<p>Next, each pallet has a configuration trait which is called <code>Trait</code>. The configuration trait can be used to access features from other pallets, or <a href="2-appetizers/../3-entrees/constants.html">constants</a> that effect the pallet's behavior. This pallet is simple enough that our configuration trait can remain empty, although it must still exist.</p>
<pre><code class="language-rust ignore">pub trait Trait: system::Trait {}
</code></pre>
<h2><a class="header" href="#dispatchable-calls" id="dispatchable-calls">Dispatchable Calls</a></h2>
<p>A Dispatchable call is a function that a blockchain user can call as part of an Extrinsic. &quot;Extrinsic&quot; is Substrate jargon meaning a call from outside of the chain. Most of the time they are transactions, and for now it is fine to think of them as transactions. Dispatchable calls are defined in the <a href="https://substrate.dev/rustdocs/master/frame_support/macro.decl_module.html"><code>decl_module!</code> macro</a>.</p>
<pre><code class="language-rust ignore">decl_module! {
	pub struct Module&lt;T: Trait&gt; for enum Call where origin: T::Origin {

		pub fn say_hello(origin) -&gt; DispatchResult {
			// --snip--
		}

		// More dispatchable calls could go here
	}
}
</code></pre>
<p>As you can see, our <code>hello-substrate</code> pallet has one dipatchable call that takes a single argument, called <code>origin</code> which we'll investigate shortly. Both calls return a <a href="https://substrate.dev/rustdocs/master/frame_support/dispatch/type.DispatchResult.html"><code>DispatchResult</code></a> which can be either <code>Ok(())</code> indicating that the call succeeded, or and <code>Err</code> which we'll investigate in the <a href="2-appetizers/./3-errors.html">appetizer about errors</a>.</p>
<h2><a class="header" href="#inside-a-dispatchable-call" id="inside-a-dispatchable-call">Inside a Dispatchable Call</a></h2>
<p>Let's take a closer look at our dispatchable call.</p>
<pre><code class="language-rust ignore">pub fn say_hello(origin) -&gt; DispatchResult {
	// Ensure that the caller is a regular keypair account
	let caller = ensure_signed(origin)?;

	// Print a message
	print(&quot;Hello World&quot;);
	// Inspecting variables
	debug::info!(&quot;Request sent by: {:?}&quot;, caller);

	// Indicate that this call succeeded
	Ok(())
}
</code></pre>
<p>This function essentially does three things. First, it uses the <a href="https://substrate.dev/rustdocs/master/frame_system/fn.ensure_signed.html"><code>ensure_signed</code> function</a> to ensure that the caller of the function was a regular user who owns a private key. This macro also returns who that caller was. We store the caller's identity in the <code>caller</code> variable.</p>
<p>Second, it prints a message and logs the caller. Notice that we aren't using Rust's normal <code>println!</code> macro, but rather a special <a href="https://substrate.dev/rustdocs/master/sp_runtime/fn.print.html"><code>print</code> function</a> and <a href="https://substrate.dev/rustdocs/master/frame_support/debug/macro.info.html"><code>debug::info!</code> macro</a>. The reason for this is explained in the next section.</p>
<p>Finally, the call returns <code>Ok(())</code> to indicate that the call has succeeded. At a glance it seems that there is no way for this call to fail, but this is not quite true. The <code>ensure_signed</code> function, used at the beginning, can return an error if the call was not from a signed origin. This is the first time we're seeing the important paradigm &quot;<strong>Verify first, write last</strong>&quot;. In Substrate development, it is important that you always ensure preconditions are met and return errors at the beginning. After these checks have completed, then you may begin the functions computation.</p>
<h2><a class="header" href="#printing-from-the-runtime" id="printing-from-the-runtime">Printing from the Runtime</a></h2>
<p>Printing to the terminal from a rust program is typically very simple using the <code>println!</code> macro. However, Substrate runtimes are compiled to Web Assembly as well as a regular native binary, and do not have access to rust's standard library. That means we cannot use the regular <code>println!</code>. I encourage you to modify the code to try using <code>println!</code> and confirm that it will not compile. Nonetheless, printing a message from the runtime is useful both for logging information, and also for debugging.</p>
<p><img src="2-appetizers/../img/substrate-architecture.png" alt="Substrate Architecture Diagram" /></p>
<p>At the top of our pallet, we imported <code>sp_runtime</code>'s <a href="https://substrate.dev/rustdocs/master/sp_runtime/fn.print.html"><code>print</code> function</a>. This special function allows the runtime to pass a message for printing to the outer part of the node which is not built to Wasm. This function is only able to print items that implement the <a href="https://substrate.dev/rustdocs/master/sp_runtime/traits/trait.Printable.html"><code>Printable</code> trait</a>. Luckily all the primitive types already implement this trait, and you can implement the trait for your own datatypes too.</p>
<p><strong>Print function note:</strong> We also need to include the flag <code>-lruntime=debug</code> when running the kitchen node.</p>
<p>The next line demonstrates using <code>debug::info!</code> macro to log to the screen and also inspecting the variable's content. The syntax inside the macro is very similar to what regular rust macro <code>println!</code> takes.</p>
<p><strong>Runtime logger note:</strong> When we execute the runtime in native, <code>debug::info!</code> messages are printed. However, if we execute the runtime in Wasm, then an additional step to initialise <a href="https://substrate.dev/rustdocs/master/frame_support/debug/struct.RuntimeLogger.html">RuntimeLogger</a> is required.</p>
<h2><a class="header" href="#installing-the-pallet-in-a-runtime" id="installing-the-pallet-in-a-runtime">Installing the Pallet in a Runtime</a></h2>
<p>In order to actually use a pallet, it must be installed in a Substrate runtime. This particular pallet is installed in the <code>super-runtime</code> which you built as part of the kitchen node. To install a pallet in a runtime, you must do three things.</p>
<h3><a class="header" href="#depend-on-the-pallet" id="depend-on-the-pallet">Depend on the Pallet</a></h3>
<p>First we must include the pallet in our runtime's <code>Cargo.toml</code> file. In the case of the super-runtime, this file is at <code>runtimes/super-runtime/Cargo.toml</code>.</p>
<pre><code class="language-toml">[dependencies]
# --snip--
hello-substrate = { path = &quot;../../pallets/hello-substrate&quot;, default-features = false }
</code></pre>
<p>Because the runtime is built to both native and Wasm, we must ensure that our pallet is built to the correct target as well. At the bottom of the <code>Cargo.toml</code> file, we see this.</p>
<pre><code class="language-toml">[features]
default = [&quot;std&quot;]
std = [
	# --snip--
	&quot;hello-substrate/std&quot;,
]
</code></pre>
<h3><a class="header" href="#implement-its-configuration-trait" id="implement-its-configuration-trait">Implement its Configuration Trait</a></h3>
<p>Next we must implement the pallet's configuration trait. This happens in the runtime's main <code>lib.rs</code> file. In the case of the super-runtime, this file is at <code>runtimes/super-runtime/src/lib.rs</code>. Because this pallet's configuration trait is trivial, so is implementing it.</p>
<pre><code class="language-rustignore">impl hello_substrate::Trait for Runtime {}
</code></pre>
<p>You can see the corresponding trait implementations in the surrounding lines. Most of them are more complex.</p>
<h3><a class="header" href="#add-it-to-construct_runtime" id="add-it-to-construct_runtime">Add it to <code>construct_runtime!</code></a></h3>
<p>Finally, we add our pallet to the <a href="https://substrate.dev/rustdocs/master/frame_support/macro.construct_runtime.html"><code>construct_runtime!</code> macro</a>.</p>
<pre><code class="language-rust ignore">construct_runtime!(
	pub enum Runtime where
		Block = Block,
		NodeBlock = opaque::Block,
		UncheckedExtrinsic = UncheckedExtrinsic
	{
		// --snip--
		HelloSubstrate: hello_substrate::{Module, Call},
	}
);
</code></pre>
<p>This macro does the heavy lifting of composing each individual pallet into a single usable runtime. Let's explain the syntax for each line. Each Pallet listed in the macro needs several pieces of information.</p>
<p>First is a convenient name to give to this pallet. We've chosen <code>HelloSubstrate</code>. It is common to choose the same name as the pallet itself except when there is <a href="2-appetizers/../3-entrees/instantiable.html">more than one instance</a>. Next is the name of the crate that the pallet lives in. And finally there is a list of features the pallet provides. All pallet require <code>Module</code>. Our pallet also provides dispatchable calls, so it requires <code>Call</code>.</p>
<h2><a class="header" href="#try-it-out" id="try-it-out">Try it Out</a></h2>
<p>If you haven't already, try interacting with the pallet using the Apps UI. You should see your message printed to the log of your node. Remember to run the kitchen node with the correct flags: <code>./kitchen-node --dev -lruntime=debug</code></p>
<p>You're now well on your way to becoming a blockchain chef. Let's continue to build our skills with another appetizer.</p>
<h1><a class="header" href="#single-value" id="single-value">Single Value</a></h1>
<p><em><a href="https://github.com/substrate-developer-hub/recipes/tree/master/pallets/single-value"><code>pallets/single-value</code></a></em></p>
<p>Storage is used for data that should be kept between blocks, and accessible to future transactions. Most runtimes will have many storage values, and together the storage values make up the blockchain's &quot;state&quot;. The storage values themselves are <em>not</em> stored in the blocks. Instead the blocks contains extrinsics which represent <em>changes</em> to the storage values. It is the job of each node in a blockchain network to keep track of the current storage. The current state of storage can be determined by executing all of the blocks in the chain.</p>
<h2><a class="header" href="#declaring-storage" id="declaring-storage">Declaring Storage</a></h2>
<p>A pallet's storage items are declared with the <a href="https://substrate.dev/rustdocs/master/frame_support/macro.decl_storage.html"><code>decl_storage!</code> macro</a>.</p>
<pre><code class="language-rust ignore">decl_storage! {
    trait Store for Module&lt;T: Trait&gt; as SingleValue {
        // --snip--
    }
}
</code></pre>
<p>The code above is boilerplate that does not change with the exception of the <code>SingleValue</code>. The macro uses this as the name for a struct that it creates. As a pallet author you don't need to worry about this value much, and it is fine to use the name of the pallet itself.</p>
<p>This pallet has two storage items, both of which are single storage values. Substrate's storage API also supports more complex storage types which are <a href="2-appetizers/../3-entrees/storage-api/index.html">covered in the entrees</a>. The fundamentals for all types are the same.</p>
<p>Our first storage item is a <code>u32</code> value which is declared with this syntax</p>
<pre><code class="language-rust ignore">StoredValue get(fn stored_value): u32;
</code></pre>
<p>The <code>StorageValue</code> is the name of the storage item, similar to a variable name. We will use this name any time we write to the storage item. The <code>get(fn stored_value)</code> is optional. It tells the <code>decl_storage!</code> macro to create a getter function for us. That means we get a function called <code>stored_value</code> which returns the value in that storage item. Finally, the <code>: u32</code> declares the type of the item.</p>
<p>The next storage item is an <code>AccountId</code>. This is not a primitive type, but rather comes from the system pallet. Types like this need to be prefixed with a <code>T::</code> as we see here.</p>
<pre><code class="language-rust ignore">StoredAccount get(fn stored_account): T::AccountId;
</code></pre>
<h2><a class="header" href="#reading-and-writing-to-storage" id="reading-and-writing-to-storage">Reading and Writing to Storage</a></h2>
<p>Functions used to access a single storage value are defined in the <a href="https://substrate.dev/rustdocs/master/frame_support/storage/trait.StorageValue.html"><code>StorageValue</code> trait</a>. In this pallet, we use the most common method, <code>put</code>, but it is worth skimming the other methods so you know what is available.</p>
<p>The <code>set_value</code> method demonstrates writing to storage, as well as taking a parameter in our dispatchable call.</p>
<pre><code class="language-rust ignore">fn set_value(origin, value: u32) -&gt; DispatchResult {
	let _ = ensure_signed(origin)?;

	StoredValue::put(value);

	Ok(())
}
</code></pre>
<p>To read a value from storage, we could use the <code>get</code> method, or we could use the getter method we declared in <code>decl_storage!</code>.</p>
<pre><code class="language-rust ignore">// The following lines are equivalent
let my_val = StoredValue::get();
let my_val = Self::stored_value();
</code></pre>
<h2><a class="header" href="#storing-the-callers-account" id="storing-the-callers-account">Storing the Callers Account</a></h2>
<p>In terms of storage, the <code>set_account</code> method is quite similar to <code>set_value</code>, but it also demonstrates how to retreive the <code>AccountId</code> of the caller using the <a href="https://substrate.dev/rustdocs/master/frame_system/fn.ensure_signed.html"><code>ensure_signed</code> function</a>.</p>
<pre><code class="language-rust ignore">fn set_account(origin) -&gt; DispatchResult {
	let who = ensure_signed(origin)?;

	&lt;StoredAccount&lt;T&gt;&gt;::put(&amp;who);

	Ok(())
}
</code></pre>
<p>Because <code>AccountId</code> type comes from the configuration trait, we must use slightly different syntax. Notice the <code>&lt;T&gt;</code> attached to the name of the storage value this time. Notice also that because <code>AccountId</code> is not primitive, we lend a reference to it rather than transferring ownership.</p>
<h2><a class="header" href="#constructing-the-runtime" id="constructing-the-runtime">Constructing the Runtime</a></h2>
<p>We learned about the <a href="https://substrate.dev/rustdocs/master/frame_support/macro.construct_runtime.html"><code>construct_runtime!</code> macro</a> in the previous section. Because this pallet uses storage items, we must add this to the line in construct runtime. In the Super Runtime, we see the additional <code>Storage</code> feature.</p>
<pre><code class="language-rust ignore">construct_runtime!(
	pub enum Runtime where
		Block = Block,
		NodeBlock = opaque::Block,
		UncheckedExtrinsic = UncheckedExtrinsic
	{
		// --snip--
		SingleValue: single_value::{Module, Call, Storage},
	}
);
</code></pre>
<h1><a class="header" href="#handling-errors" id="handling-errors">Handling Errors</a></h1>
<p><em><a href="https://github.com/substrate-developer-hub/recipes/tree/master/pallets/adding-machine"><code>pallets/adding-machine</code></a></em></p>
<p>As we've mentioned before, in Substrate development, it is important to <strong>Verify first, write last</strong>. In this recipe, we'll create an adding machine checks for unlucky numbers (a silly example) as well as integer overflow (a serious and realistic example), and throws the appropriate errors.</p>
<h2><a class="header" href="#declaring-errors" id="declaring-errors">Declaring Errors</a></h2>
<p>Errors are declared with the <a href="https://substrate.dev/rustdocs/master/frame_support/macro.decl_error.html"><code>decl_error!</code> macro</a>. Although it is optional, it is good practice to write doc comments for each error variant as demonstrated here.</p>
<pre><code class="language-rust ignore">decl_error! {
	pub enum Error for Module&lt;T: Trait&gt; {
		/// Thirteen is unlucky and prohibitted
		UnluckyThirteen,
		/// Sum would have overflowed if we had added
		SumTooLarge,
	}
}
</code></pre>
<h2><a class="header" href="#throwing-errors-in-match-statement" id="throwing-errors-in-match-statement">Throwing Errors in <code>match</code> Statement</a></h2>
<p>Errors can be thrown in two different ways, both of which are demonstrated in the the <code>add</code> dispatchable call. The first is with the <a href="https://substrate.dev/rustdocs/master/frame_support/macro.ensure.html"><code>ensure!</code> macro</a> where the error to throw is the second parameter. The second is to throw the error by explicitly returning it.</p>
<pre><code class="language-rust ignore">fn add(origin, val_to_add: u32) -&gt; DispatchResult {
	let _ = ensure_signed(origin)?;

	// First check for unlucky number 13
	ensure!(val_to_add != 13, &lt;Error&lt;T&gt;&gt;::UnluckyThirteen);

	// Now check for overflow while adding
	let result = match Self::sum().checked_add(val_to_add) {
		Some(r) =&gt; r,
		None =&gt; return Err(&lt;Error&lt;T&gt;&gt;::SumTooLarge.into()),
	};

	// Write the new sum to storage
	Sum::put(result);

	Ok(())
}
</code></pre>
<p>Notice that the <code>Error</code> type always takes the generic parameter <code>T</code>. Notice also that we have verified all preconditions, and thrown all possible errors before ever writing to storage.</p>
<h2><a class="header" href="#throwing-errors-with-ok_or-and-map_err" id="throwing-errors-with-ok_or-and-map_err">Throwing Errors with <code>.ok_or</code> and <code>.map_err</code></a></h2>
<p>In fact, the pattern of:</p>
<ul>
<li>calling functions that returned a <code>Result</code> or <code>Option</code>, and</li>
<li>checking if the result is <code>Some</code> or <code>Ok</code>. If not, returns from the function early with an error</li>
</ul>
<p>are so common that there are two standard Rust methods help performing the task.</p>
<pre><code class="language-rust ignore">fn add_alternate(origin, val_to_add: u32) -&gt; DispatchResult {
	let _ = ensure_signed(origin)?;

	ensure!(val_to_add != 13, &lt;Error&lt;T&gt;&gt;::UnluckyThirteen);

	// Using `ok_or()` to check if the returned value is `Ok` and unwrap the value.
	//   If not, returns error from the function.
	let result = Self::sum().checked_add(val_to_add).ok_or(&lt;Error&lt;T&gt;&gt;::SumTooLarge)?;

	Sum::put(result);
	Ok(())
}
</code></pre>
<p>Notice the pattern of <code>.ok_or(&lt;Error&lt;T&gt;&gt;::MyError)?;</code>. This is really handy when you have a function call that returns an <code>Option</code> and you expect there should be a value inside. If not, returns early with an error message, all the while unwrapping the value for your further processing.</p>
<p>If your function returns a <code>Result&lt;T, E&gt;</code>, you could apply <code>.map_err(|_e| &lt;Error&lt;T&gt;&gt;::MyError)?;</code> in the same spirit.</p>
<h2><a class="header" href="#constructing-the-runtime-1" id="constructing-the-runtime-1">Constructing the Runtime</a></h2>
<p>Unlike before, adding errors to our pallet does <em>not</em> require a change to the line in <code>construct_runtime!</code>. This is just an idiosyncrasy of developing in Substrate.</p>
<h1><a class="header" href="#using-events" id="using-events">Using Events</a></h1>
<p><em><a href="https://github.com/substrate-developer-hub/recipes/tree/master/pallets/simple-event"><code>pallets/simple-event</code></a></em>, <em><a href="https://github.com/substrate-developer-hub/recipes/tree/master/pallets/generic-event"><code>pallets/generic-event</code></a></em></p>
<p>Having a <a href="https://docs.substrate.dev/docs/glossary#section-transaction">transaction</a> included in a block does not guarantee that the function executed successfully. As we saw in the previous recipe, many calls can cause errors, but still be included in a block. To verify that functions have executed successfully, emit an <a href="https://docs.substrate.dev/docs/glossary#section-events">event</a> at the bottom of the function body.</p>
<p>Events notify the off-chain world of successful state transitions.</p>
<h2><a class="header" href="#some-prerequisites" id="some-prerequisites">Some Prerequisites</a></h2>
<p>When using events, we have to include the <code>Event</code> type in our configuration trait. Although the syntax is a bit complex, it is the same every time. If you are a skilled Rust programmer you will recognize this as a series of <a href="https://doc.rust-lang.org/book/ch10-02-traits.html">trait bounds</a>. If you don't recognize this feature of Rust yet, don't worry; it is the same every time, so you can just copy it and move on.</p>
<pre><code class="language-rust ignore">pub trait Trait: system::Trait {
	type Event: From&lt;Event&gt; + Into&lt;&lt;Self as system::Trait&gt;::Event&gt;;
}
</code></pre>
<p>Next we have to add a line inside of the <code>decl_module!</code> macro which generates the 	<code>deposit_event</code> function we'll use later when emitting our events. Even experienced Rust programmers will not recognize this syntax because it is unique to this macro. Just copy it each time.</p>
<pre><code class="language-rust ignore">decl_module! {
	pub struct Module&lt;T: Trait&gt; for enum Call where origin: T::Origin {

		// This line is new
		fn deposit_event() = default;

		// --snip--
	}
}
</code></pre>
<h2><a class="header" href="#declaring-events" id="declaring-events">Declaring Events</a></h2>
<p>To declare an event, use the <a href="https://substrate.dev/rustdocs/master/frame_support/macro.decl_event.html"><code>decl_event!</code> macro</a>. Like any rust enum, Events have names, and can optionally carry data with them. The syntax is slightly different depending on whether the events carry data of primitive types, or generic types from the pallet's configuration trait. These two techniques are demonstrated in the <code>simple-event</code> and <code>generic-event</code> pallets respectively.</p>
<h3><a class="header" href="#simple-events" id="simple-events">Simple Events</a></h3>
<p>The simplest example of an event uses the following syntax</p>
<pre><code class="language-rust ignore">decl_event!(
	pub enum Event {
		EmitInput(u32),
	}
);
</code></pre>
<h3><a class="header" href="#events-with-generic-types" id="events-with-generic-types">Events with Generic Types</a></h3>
<p><a href="https://github.com/substrate-developer-hub/recipes/tree/master/pallets/generic-event">Sometimes</a> events might contain types from the pallet's Configuration Trait. In this case, it is necessary to specify additional syntax</p>
<pre><code class="language-rust ignore">decl_event!(
	pub enum Event&lt;T&gt; where AccountId = &lt;T as system::Trait&gt;::AccountId {
		EmitInput(AccountId, u32),
	}
);
</code></pre>
<p>This example also demonstrates how the <code>where</code> clause can be used to specify type aliasing for more readable code.</p>
<h2><a class="header" href="#emitting-events" id="emitting-events">Emitting Events</a></h2>
<p>Events are emitted from dispatchable calls using the <code>deposit_event</code> method.</p>
<h3><a class="header" href="#simple-events-1" id="simple-events-1">Simple Events</a></h3>
<p>The event is emitted at the bottom of the <code>do_something</code> function body.</p>
<pre><code class="language-rust ignore">Self::deposit_event(Event::EmitInput(new_number));
</code></pre>
<h3><a class="header" href="#events-with-generic-types-1" id="events-with-generic-types-1">Events with Generic Types</a></h3>
<p>The syntax for <code>deposit_event</code> now takes the <code>RawEvent</code> type because it is generic over the pallet's configuration trait.</p>
<pre><code class="language-rust ignore">Self::deposit_event(RawEvent::EmitInput(user, new_number));
</code></pre>
<h3><a class="header" href="#constructing-the-runtime-2" id="constructing-the-runtime-2">Constructing the Runtime</a></h3>
<p>For the first time in the recipes, our pallet has an associated type in its configuration trait. We must specify this type when implementing its trait. In the case of the <code>Event</code> type, this is entirely straight forward, and looks the same for both simple events and generic events.</p>
<pre><code class="language-rust ignore">impl simple_event::Trait for Runtime {
	type Event = Event;
}
</code></pre>
<p>Events, like dispatchable calls and storage items, requires a slight change to the line in <code>construct_runtime!</code>. Notice that the <code>&lt;T&gt;</code> is necessary for generic events.</p>
<pre><code class="language-rust ignore">construct_runtime!(
	pub enum Runtime where
		Block = Block,
		NodeBlock = opaque::Block,
		UncheckedExtrinsic = UncheckedExtrinsic
	{
		// --snip--
		GenericEvent: generic_event::{Module, Call, Event&lt;T&gt;},
		SimpleEvent: simple_event::{Module, Call, Event},
	}
);
</code></pre>
<h1><a class="header" href="#entrees" id="entrees">Entrees</a></h1>
<p>These Entrees are for chefs who have the basics down. If you've read through the first two chapters of this cookbook, that includes you! The entrees cover a wide variety of topics in Substrate development, and are meant to be read in <em>any order</em>.</p>
<h1><a class="header" href="#storage-api" id="storage-api">Storage API</a></h1>
<p>We've already encountered the <a href="https://substrate.dev/rustdocs/master/frame_support/macro.decl_storage.html"><code>decl_storage!</code> macro</a> in the appetizer on <a href="3-entrees/storage-api/../../2-appetizers/2-storage-values.html">storage items</a>. There is a rich storage API in Substrate which we will explore in this section.</p>
<p>For crypto<em>currencies</em>, storage might consist of a mapping between account keys and corresponding balances.</p>
<p>More generally, blockchains provide an interface to store and interact with data in a verifiable and globally irreversible way. In this context, data is stored in a series of snapshots, each of which may be accessed at a later point in time, but, once created, snapshots are considered irreversible.</p>
<p>Arbitrary data may be stored, as long as its data type is serializable in Substrate i.e. implements <a href="https://docs.rs/parity-scale-codec/1.0.6/parity_scale_codec/#encode"><code>Encode</code></a> and <a href="https://docs.rs/parity-scale-codec/1.0.6/parity_scale_codec/#decode"><code>Decode</code></a> traits.</p>
<p>The previous <em><a href="3-entrees/storage-api/../../2-appetizers/2-storage-values.html">single-value storage recipe</a></em> showed how a single value can be stored in runtime storage. In this section, we cover</p>
<ul>
<li><a href="3-entrees/storage-api/./cache.html">caching values rather than calling to storage multiple times</a></li>
<li><a href="3-entrees/storage-api/./iterate.html">storing sets, checking membership, and iteration</a></li>
<li><a href="3-entrees/storage-api/./enumerated.html">ordered lists with basic maps and linked maps</a></li>
<li><a href="3-entrees/storage-api/./double.html">efficient subgroup removal by key prefix with double maps</a></li>
<li><a href="3-entrees/storage-api/./structs.html">storing custom structs</a></li>
</ul>
<p><em>in-progress</em></p>
<ul>
<li><a href="3-entrees/storage-api/./childtries.html">cheap inclusion proofs with child tries</a></li>
</ul>
<h1><a class="header" href="#cache-multiple-calls" id="cache-multiple-calls">Cache Multiple Calls</a></h1>
<p><em><a href="https://github.com/substrate-developer-hub/recipes/tree/master/pallets/storage-cache"><code>pallets/storage-cache</code></a></em></p>
<p>Calls to runtime storage have an associated cost. With this in mind, multiple calls to storage values should be avoided when possible.</p>
<pre><code class="language-rust ignore">decl_storage! {
    trait Store for Module&lt;T: Trait&gt; as StorageCache {
        // copy type
        SomeCopyValue get(fn some_copy_value): u32;

        // clone type
        KingMember get(fn king_member): T::AccountId;
        GroupMembers get(fn group_members): Vec&lt;T::AccountId&gt;;
    }
}
</code></pre>
<p>For <a href="https://doc.rust-lang.org/std/marker/trait.Copy.html"><code>Copy</code></a> types, it is easy to reuse previous storage calls by simply reusing the value (which is automatically cloned upon reuse). With this in mind, the second call in the following code is unnecessary:</p>
<pre><code class="language-rust ignore">fn swap_value_no_cache(origin, some_val: u32) -&gt; Result {
    let _ = ensure_signed(origin)?;
    let original_call = &lt;SomeCopyValue&gt;::get();
    let some_calculation = original_call + some_val;
    // this next storage call is unnecessary and is wasteful
    let unnecessary_call = &lt;SomeCopyValue&gt;::get();
    // should've just used first_call here because u32 is copy
    let another_calculation = some_calculation + unnecessary_call;
    &lt;SomeCopyValue&gt;::put(another_calculation);
    let now = &lt;system::Module&lt;T&gt;&gt;::block_number();
    Self::deposit_event(RawEvent::InefficientValueChange(another_calculation, now));
    Ok(())
}
</code></pre>
<p>Instead, the initial call value should be reused. In this example, the <code>SomeCopyValue</code> value is <a href="https://doc.rust-lang.org/std/marker/trait.Copy.html"><code>Copy</code></a> so we should prefer the following code without the unnecessary second call to storage:</p>
<pre><code class="language-rust ignore">fn swap_value_w_copy(origin, some_val: u32) -&gt; Result {
    let _ = ensure_signed(origin)?;
    let original_call = &lt;SomeCopyValue&gt;::get();
    let some_calculation = original_call + some_val;
    // uses the original_call because u32 is copy
    let another_calculation = some_calculation + original_call;
    &lt;SomeCopyValue&gt;::put(another_calculation);
    let now = &lt;system::Module&lt;T&gt;&gt;::block_number();
    Self::deposit_event(RawEvent::InefficientValueChange(another_calculation, now));
    Ok(())
}
</code></pre>
<p>If the type was not <code>Copy</code>, but was <a href="https://doc.rust-lang.org/std/clone/trait.Clone.html"><code>Clone</code></a>, then it is still preferred to clone the value in the method than to make another call to runtime storage.</p>
<pre><code class="language-rust ignore">decl_storage! {
    trait Store for Module&lt;T: Trait&gt; as StorageCache {
        // ...&lt;copy type here&gt;...
        // clone type
        KingMember get(fn king_member): T::AccountId;
        GroupMembers get(fn group_members): Vec&lt;T::AccountId&gt;;
    }
}
</code></pre>
<p>The runtime methods enable the calling account to swap the <code>T::AccountId</code> value in storage if</p>
<ol>
<li>the existing storage value is not in <code>GroupMembers</code> AND</li>
<li>the calling account is in `Group Members</li>
</ol>
<p>The first implementation makes a second unnecessary call to runtime storage instead of cloning the call for <code>existing_key</code>:</p>
<pre><code class="language-rust ignore">fn swap_king_no_cache(origin) -&gt; Result {
    let new_king = ensure_signed(origin)?;
    let existing_king = &lt;KingMember&lt;T&gt;&gt;::get();

    // only places a new account if
    // (1) the existing account is not a member &amp;&amp;
    // (2) the new account is a member
    ensure!(!Self::is_member(existing_king), &quot;is a member so maintains priority&quot;);
    ensure!(Self::is_member(new_king.clone()), &quot;not a member so doesn't get priority&quot;);

    // BAD (unnecessary) storage call
    let old_king = &lt;KingMember&lt;T&gt;&gt;::get();
    // place new king
    &lt;KingMember&lt;T&gt;&gt;::put(new_king.clone());

    Self::deposit_event(RawEvent::InefficientKingSwap(old_king, new_king));
    Ok(())
}
</code></pre>
<p>If the <code>existing_key</code> is used without a <code>clone</code> in the event emission instead of <code>old_king</code>, then the compiler returns the following error</p>
<pre><code class="language-bash">error[E0382]: use of moved value: `existing_king`
  --&gt; src/lib.rs:93:63
   |
80 |             let existing_king = &lt;KingMember&lt;T&gt;&gt;::get();
   |                 ------------- move occurs because `existing_king` has type `&lt;T as frame_system::Trait&gt;::AccountId`, which does not implement the `Copy` trait
...
85 |             ensure!(!Self::is_member(existing_king), &quot;is a member so maintains priority&quot;);
   |                                      ------------- value moved here
...
93 |             Self::deposit_event(RawEvent::InefficientKingSwap(existing_king, new_king));
   |                                                               ^^^^^^^^^^^^^ value used here after move

error: aborting due to previous error

For more information about this error, try `rustc --explain E0382`.
error: Could not compile `storage-cache`.

To learn more, run the command again with --verbose.
</code></pre>
<p>Fixing this only requires cloning the original call to storage before it is moved:</p>
<pre><code class="language-rust ignore">fn swap_king_with_cache(origin) -&gt; Result {
    let new_king = ensure_signed(origin)?;
    let existing_king = &lt;KingMember&lt;T&gt;&gt;::get();
    // clone before existing_king is moved
    let old_king = existing_king.clone();

    // existing king is moved next
    ensure!(!Self::is_member(existing_king), &quot;is a member so maintains priority&quot;);
    ensure!(Self::is_member(new_king.clone()), &quot;not a member so doesn't get priority&quot;);

    // &lt;no (unnecessary) storage call here&gt;
    // place new king
    &lt;KingMember&lt;T&gt;&gt;::put(new_king.clone());

    // use cached old_king value here
    Self::deposit_event(RawEvent::BetterKingSwap(old_king, new_king));
    Ok(())
}
</code></pre>
<p>Not all types implement <a href="https://doc.rust-lang.org/std/marker/trait.Copy.html"><code>Copy</code></a> or <a href="https://doc.rust-lang.org/std/clone/trait.Clone.html"><code>Clone</code></a>, so it is important to discern other patterns that minimize and alleviate the cost of calls to storage.</p>
<h1><a class="header" href="#set-storage-and-iteration" id="set-storage-and-iteration">Set Storage and Iteration</a></h1>
<p><em><a href="https://github.com/substrate-developer-hub/recipes/tree/master/pallets/vec-set"><code>pallets/vec-set</code></a></em></p>
<p>Storing a vector in the runtime can often be useful for managing groups and verifying membership. This recipe discusses common patterns encounted when storing vectors in runtime storage.</p>
<ul>
<li><a href="3-entrees/storage-api/iterate.html#group">verifying group membership</a></li>
<li><a href="3-entrees/storage-api/iterate.html#append">Append vs Mutate</a></li>
<li><a href="3-entrees/storage-api/iterate.html#iterate">Iteration in the Runtime</a></li>
</ul>
<h2><a class="header" href="#verifying-group-membership-a-name--groupa" id="verifying-group-membership-a-name--groupa">Verifying Group Membership <a name = "group"></a></a></h2>
<p>To maintain a set of <code>AccountId</code> to establish group ownership of decisions, it is straightforward to store a vector in the runtime of <code>AccountId</code>.</p>
<pre><code class="language-rust ignore">decl_storage! {
	trait Store for Module&lt;T: Trait&gt; as VecMap {
        Members get(fn members): Vec&lt;T::AccountId&gt;;
	}
}
</code></pre>
<p>It is easy to add the following helper method to verify membership elsewhere in the runtime.</p>
<pre><code class="language-rust ignore">impl&lt;T: Trait&gt; Module&lt;T&gt; {
    fn is_member(who: &amp;T::AccountId) -&gt; bool {
        &lt;Members&lt;T&gt;&gt;::get().contains(who)
    }
}
</code></pre>
<p>This helper method can be placed in other runtime methods to restrict certain changes to runtime storage to privileged groups. Depending on the incentive structure of the network/chain, the members in these groups may have earned membership and the subsequent access rights through loyal contributions to the system.</p>
<pre><code class="language-rust ignore">// use support::ensure
fn member_action(origin) -&gt; Result {
    let member = ensure_signed(origin)?;
    ensure!(Self::is_member(&amp;member), &quot;not a member =&gt; cannot do action&quot;);
    // &lt;action &amp;&amp; || storage change&gt;
    Ok(())
}
</code></pre>
<p>In this example, the helper method facilitates isolation of runtime storage access rights according to membership. In general, <strong>place <code>ensure!</code> checks at the top of each runtime function's logic to verify that all of the requisite checks pass before performing any storage changes.</strong></p>
<blockquote>
<p>NOTE: <em><a href="https://github.com/substrate-developer-hub/recipes/issues/35">child trie</a> storage provides a more efficient data structure for tracking group membership</em></p>
</blockquote>
<h2><a class="header" href="#append-vs-mutate" id="append-vs-mutate">Append vs. Mutate</a></h2>
<pre><code class="language-rust ignore">decl_storage! {
	trait Store for Module&lt;T: Trait&gt; as VecMap {
	    CurrentValues get(fn current_values): Vec&lt;u32&gt;;
        NewValues get(fn new_values): Vec&lt;u32&gt;;
	}
}
</code></pre>
<p>Before <a href="https://github.com/paritytech/substrate/pull/3071">3071</a> was merged, it was necessary to call <a href="https://substrate.dev/rustdocs/master/frame_support/storage/trait.StorageValue.html#tymethod.mutate"><code>mutate</code></a> to push new values to a vector stored in runtime storage.</p>
<pre><code class="language-rust ignore">fn mutate_to_append(origin) -&gt; Result {
    let user = ensure_signed(origin)?;

    // this decodes the existing vec, appends the new values, and re-encodes the whole thing
    &lt;CurrentValues&gt;::mutate(|v| v.extend_from_slice(&amp;Self::new_values()));
    Self::deposit_event(RawEvent::MutateToAppend(user));
    Ok(())
}
</code></pre>
<p>For vectors stored in the runtime, mutation can be relatively expensive. This follows from the fact that <code>mutate</code> entails decoding the vector, making changes, and re-encoding the whole vector. It seems wasteful to decode the entire vector, push a new item, and then re-encode the whole thing. This provides sufficient motivation for <a href="https://substrate.dev/rustdocs/master/frame_support/storage/trait.StorageValue.html#tymethod.append"><code>append</code></a>:</p>
<pre><code class="language-rust ignore">fn append_new_entries(origin) -&gt; Result {
    let user = ensure_signed(origin)?;

    // this encodes the new values and appends them to the already encoded existing evc
    let mut current_values = Self::current_values();
    current_values.append(&amp;mut Self::new_values());
    Self::deposit_event(RawEvent::AppendVec(user));
    Ok(())
}
</code></pre>
<p><code>append</code> encodes the new values, and pushes them to the already encoded vector without decoding the existing entries. This method removes the unnecessary steps for decoding and re-encoding the unchanged elements.</p>
<h2><a class="header" href="#iteration-in-the-runtime-a-name--iteratea" id="iteration-in-the-runtime-a-name--iteratea">Iteration in the Runtime <a name = "iterate"></a></a></h2>
<p>In general, iteration in the runtime should be avoided. <em>In the future</em>, <a href="https://github.com/substrate-developer-hub/recipes/issues/45">offchain-workers</a> may provide a less expensive way to iterate over runtime storage items. Moreover, <em><a href="https://github.com/substrate-developer-hub/recipes/issues/35">child tries</a></em> enable cheap inclusion proofs without the same lookup costs associated with vectors.</p>
<p>Even so, there are a few tricks to alleviate the costs of iterating over runtime storage items like vectors. For example, it is <a href="https://twitter.com/heinz_gies/status/1121490424739303425">cheaper to iterate over a slice</a> than a vector. With this in mind, store items in the runtime as vectors and transform them into slices after making storage calls. <a href="https://github.com/paritytech/substrate/pull/3041">3041</a> introduced <code>insert_ref</code> and <code>put_ref</code> in order to allow equivalent reference-style types to be placed without copy (e.g. a storage item of <code>Vec&lt;AccountId&gt;</code> can now be written from a <code>&amp;[AccountId]</code>). This enables greater flexibility when working with slices that are associated with vectors stored in the runtime.</p>
<h1><a class="header" href="#lists-maps-vs-linked-maps" id="lists-maps-vs-linked-maps">Lists: Maps vs Linked Maps</a></h1>
<p><em><a href="https://github.com/substrate-developer-hub/recipes/tree/master/pallets/linked-map"><code>pallets/linked-map</code></a></em></p>
<p>Substrate does not natively support a list type since it may encourage dangerous habits. Unless explicitly guarded against, a list will add unbounded <code>O(n)</code> complexity to an operation that will only charge <code>O(1)</code> fees (<a href="https://rob-bell.net/2009/06/a-beginners-guide-to-big-o-notation/">Big O notation refresher</a>). This opens an economic attack vector on your chain.</p>
<p>Emulate a list with a mapping and a counter like so:</p>
<pre><code class="language-rust ignore">use support::{StorageValue, StorageMap};

decl_storage! {
    trait Store for Module&lt;T: Trait&gt; as Example {
        TheList get(fn the_list): map u32 =&gt; T::AccountId;
        TheCounter get(fn the_counter): u32;
    }
}
</code></pre>
<p>This code allows us to store a list of participants in the runtime represented by <code>AccountId</code>s. Of course, this implementation leaves many unanswered questions such as</p>
<ul>
<li>How to add and remove elements?</li>
<li>How to maintain order under mutating operations?</li>
<li>How to verify that an element exists before removing/mutating it?</li>
</ul>
<p>This recipe answers those questions with snippets from relevant code samples:</p>
<ul>
<li><a href="3-entrees/storage-api/enumerated.html#unbounded">Adding/Removing Elements in an Unordered List</a></li>
<li><a href="3-entrees/storage-api/enumerated.html#swappop">Swap and Pop for Ordered Lists</a></li>
<li><a href="3-entrees/storage-api/enumerated.html#linkedmap">Linked Map for Simplified Enumeration</a></li>
</ul>
<p><strong>Note</strong>: It is important to properly handle <a href="3-entrees/storage-api/../safemath.html">overflow/underflow</a> and verify other relevant conditions for safety.</p>
<h2><a class="header" href="#addingremoving-elements-in-an-unbounded-list-a-name--unboundeda" id="addingremoving-elements-in-an-unbounded-list-a-name--unboundeda">Adding/Removing Elements in an Unbounded List <a name = "unbounded"></a></a></h2>
<p>If the size of the list is not relevant, the implementation is straightforward. To add an <code>AccountId</code>, increment the <code>the_counter</code> and insert an <code>AccountId</code> at that index:</p>
<pre><code class="language-rust ignore">fn add_member(origin) -&gt; Result {
    let who = ensure_signed(origin)?;

    let new_count = &lt;TheCounter&lt;T&gt;&gt;::get() + 1;
    // insert new member at next highest index
    &lt;TheList&lt;T&gt;&gt;::insert(new_count, who.clone());
    // increment counter
    &lt;TheCounter&lt;T&gt;&gt;::put(new_count);

    Self::deposit_event(RawEvent::MemberAdded(who));

    Ok(())
}
</code></pre>
<p>To remove an <code>AccountId</code>, call the <code>remove</code> method for the <code>StorageMap</code> type at the relevant index. In this case, it isn't necessary to update the indices of other <code>proposal</code>s; order is not relevant.</p>
<pre><code class="language-rust ignore">fn remove_member_unbounded(origin, index: u32) -&gt; Result {
    let who = ensure_signed(origin)?;

    // verify existence
    ensure!(&lt;TheList&lt;T&gt;&gt;::exists(index), &quot;an element doesn't exist at this index&quot;);
    // for event emission
    let removed_member = &lt;TheList&lt;T&gt;&gt;::get(index);
    // remove member at provided index
    &lt;TheList&lt;T&gt;&gt;::remove(index);

    Self::deposit_event(RawEvent::MemberRemoved(removed_member));

    Ok(())
}
</code></pre>
<p>Because the code doesn't update the indices of other <code>AccountId</code>s in the map, it is necessary to verify an <code>AccountId</code>'s existence before removing it, mutating it, or performing any other operation.</p>
<h2><a class="header" href="#swap-and-pop-for-ordered-lists-a-name--swappopa" id="swap-and-pop-for-ordered-lists-a-name--swappopa">Swap and Pop for Ordered Lists <a name = "swappop"></a></a></h2>
<p>To preserve storage so that the list doesn't continue growing even after removing elements, invoke the <strong>swap and pop</strong> algorithm:</p>
<ol>
<li>swap the element to be removed with the element at the head of the <em>list</em> (the element with the highest index in the map)</li>
<li>remove the element recently placed at the highest index</li>
<li>decrement the <code>TheCount</code> value.</li>
</ol>
<p>Use the <em>swap and pop</em> algorithm to remove elements from the list.</p>
<pre><code class="language-rust ignore">fn remove_member_bounded(origin, index: u32) -&gt; Result {
    let _ = ensure_signed(origin)?;

    ensure!(&lt;TheList&lt;T&gt;&gt;::exists(index), &quot;an element doesn't exist at this index&quot;);

    let largest_index = &lt;TheCounter&gt;::get();
    let member_to_remove = &lt;TheList&lt;T&gt;&gt;::take(index);
    // swap
    if index != largest_index {
        let temp = &lt;TheList&lt;T&gt;&gt;::take(largest_index);
        &lt;TheList&lt;T&gt;&gt;::insert(index, temp);
        &lt;TheList&lt;T&gt;&gt;::insert(largest_index, member_to_remove.clone());
    }
    // pop
    &lt;TheList&lt;T&gt;&gt;::remove(largest_index);
    &lt;TheCounter&gt;::mutate(|count| *count - 1);

    Self::deposit_event(RawEvent::MemberRemoved(member_to_remove.clone()));

    Ok(())
}
</code></pre>
<h3><a class="header" href="#linked-map-a-name--linkedmapa" id="linked-map-a-name--linkedmapa">Linked Map <a name = "linkedmap"></a></a></h3>
<p>To trade performance for <em>relatively</em> simple code, use the <code>linked_map</code> data structure. By implementing <a href="https://substrate.dev/rustdocs/master/frame_support/storage/trait.StorageLinkedMap.html"><code>StorageLinkedMap</code></a> in addition to <a href="https://substrate.dev/rustdocs/master/frame_support/storage/trait.StorageMap.html"><code>StorageMap</code></a>, <code>linked_map</code> provides a method <code>head</code> which yields the head of the <em>list</em>, thereby making it unnecessary to also store the <code>LargestIndex</code> (the <em>counters</em>). The <code>enumerate</code> method also returns an <code>Iterator</code> ordered according to when <code>(key, value)</code> pairs were inserted into the map.</p>
<p>To use <code>linked_map</code>, import <code>EnumerableStorageMap</code>. Here is the new declaration in the <code>decl_storage</code> block:</p>
<pre><code class="language-rust ignore">use support::{StorageMap, EnumerableStorageMap}; // no StorageValue necessary

decl_storage! {
    trait Store for Module&lt;T: Trait&gt; as Example {
        LinkedList get(fn linked_list): linked_map u32 =&gt; T::AccountId;
        LinkedCounter get(fn linked_counter): u32;
    }
}
</code></pre>
<p>The method adding members is no different than the previously covered method, but the <code>remove_member_linked</code> method expresses swap and pop in a different way</p>
<pre><code class="language-rust ignore">fn remove_member_linked(origin, index: u32) -&gt; Result {
    let _ = ensure_signed(origin)?;

    ensure!(&lt;LinkedList&lt;T&gt;&gt;::exists(index), &quot;A member does not exist at this index&quot;);

    let head_index = &lt;LinkedList&lt;T&gt;&gt;::head().unwrap();
    // swap
    let member_to_remove = &lt;LinkedList&lt;T&gt;&gt;::take(index);
    let head_member = &lt;LinkedList&lt;T&gt;&gt;::take(head_index);
    &lt;LinkedList&lt;T&gt;&gt;::insert(index, head_member);
    &lt;LinkedList&lt;T&gt;&gt;::insert(head_index, member_to_remove);
    // pop
    &lt;LinkedList&lt;T&gt;&gt;::remove(head_index);

    Ok(())
}
</code></pre>
<p>This implementation incurs some performance costs (vs solely using <code>StorageMap</code> and <code>StorageValue</code>) because <code>linked_map</code> heap allocates the entire map as an iterator in order to implement the <a href="https://substrate.dev/rustdocs/master/frame_support/storage/trait.StorageLinkedMap.html#tymethod.enumerate"><code>enumerate</code> method</a>.</p>
<h1><a class="header" href="#efficent-subgroup-removal-by-subkey-double-maps" id="efficent-subgroup-removal-by-subkey-double-maps">Efficent Subgroup Removal by Subkey: Double Maps</a></h1>
<p><em><a href="https://github.com/substrate-developer-hub/recipes/tree/master/pallets/double-map"><code>pallets/double-map</code></a></em></p>
<p>For some runtimes, it may be necessary to remove a subset of values in a key-value mapping. If the subset maintain an associated identifier type, this can be done in a clean way with the <a href="https://substrate.dev/rustdocs/master/frame_support/storage/trait.StorageDoubleMap.html"><code>double_map</code></a> via the <code>remove_prefix</code> api.</p>
<pre><code class="language-rust ignore">pub type GroupIndex = u32; // this is Encode (which is necessary for double_map)

decl_storage! {
	trait Store for Module&lt;T: Trait&gt; as Dmap {
		/// Member score (double map)
		MemberScore get(fn member_score):
			double_map hasher(blake2_256) GroupIndex, hasher(blake2_256) T::AccountId =&gt; u32;
		/// Get group ID for member
		GroupMembership get(fn group_membership): map hasher(blake2_256) T::AccountId =&gt; GroupIndex;
		/// For fast membership checks, see check-membership recipe for more details
		AllMembers get(fn all_members): Vec&lt;T::AccountId&gt;;
	}
}
</code></pre>
<p>For the purposes of this example,  store the scores of each members in a map that associates this <code>u32</code> value with two keys: (1) the hash of the member's <code>AccountId</code> and (2) a <code>GroupIndex</code> identifier. This allows for efficient removal of all values associated with a specific <code>GroupIndex</code> identifier.</p>
<pre><code class="language-rust ignore">fn remove_group_score(origin, group: GroupIndex) -&gt; Result {
    let member = ensure_signed(origin)?;

    let group_id = &lt;GroupMembership&lt;T&gt;&gt;::get(member);
    // check that the member is in the group (could be improved by requiring n-of-m member support)
    ensure!(group_id == group, &quot;member isn't in the group, can't remove it&quot;);

    // allows us to remove all group members from MemberScore at once
    &lt;MemberScore&lt;T&gt;&gt;::remove_prefix(&amp;group_id);

    Self::deposit_event(RawEvent::RemoveGroup(group_id));
    Ok(())
}
</code></pre>
<p><strong>Note</strong>: It is necessary for one of the two keys to be hashed; <em><a href="https://github.com/substrate-developer-hub/recipes/issues/46">TODO</a></em></p>
<h1><a class="header" href="#child-tries" id="child-tries">Child Tries</a></h1>
<p><em><a href="https://github.com/substrate-developer-hub/recipes/tree/master/pallets/child-trie"><code>pallets/child-trie</code></a></em>, <em><a href="https://github.com/substrate-developer-hub/recipes/tree/master/pallets/simple-crowdfund"><code>pallets/simple-crowdfund</code></a></em></p>
<ul>
<li><a href="3-entrees/storage-api/childtries.html#storj">Runtime Child Storage</a></li>
<li><a href="3-entrees/storage-api/childtries.html#smplcrwd">Crowdfund Example</a></li>
</ul>
<p>A <a href="https://en.wikipedia.org/wiki/Trie">trie</a> is an ordered tree structure for managing dynamic sets. For any given parent node, all descendants (children) share a common prefix associated with the parent.</p>
<p>This construction lends itself to efficient removal of subgroups of a dataset (similar to <a href="3-entrees/storage-api/./double.html"><code>double_map</code></a>). By associating a common prefix with related data, the dataset can be partitioned to effectively batch deletions.</p>
<p>Every change in the leaves percolates up to the root, thereby providing a complete, succinct history of all changes to the underlying data structure in the form of the trie root hash.</p>
<h2><a class="header" href="#runtime-child-storage-a-name--storja" id="runtime-child-storage-a-name--storja">Runtime Child Storage <a name = "storj"></a></a></h2>
<p>To interact with child tries, there are methods exposed in <a href="https://substrate.dev/rustdocs/master/frame_support/storage/child/index.html">runtime child storage</a>. Of the methods listed in the documentation, it is worth emphasizing the method associated with batch deletion.</p>
<pre><code class="language-rust ignore">/// Remove all `storage_key` key/values
pub fn kill_storage(storage_key: &amp;[u8]) {
	runtime_io::kill_child_storage(storage_key)
}

/// Remove value associated with `key` in trie with `storage_key`
pub fn kill(storage_key: &amp;[u8], key: &amp;[u8]) {
	runtime_io::clear_child_storage(storage_key, key);
}
</code></pre>
<p><a href="https://substrate.dev/rustdocs/master/frame_support/storage/child/fn.kill_storage.html"><code>kill_storage</code></a> deletes all  <code>(key, value)</code> pairs associated with the <code>storage_key</code>. The basic API for interacting with a given child trie follows this format:</p>
<pre><code class="language-rust ignore">// pseudocode
child::do(trie_id, key, value);
</code></pre>
<p>To put an object in a child trie, the code would look something like</p>
<pre><code class="language-rust ignore">fn kv_put(index: ObjectCount, who: &amp;T::AccountId, value_type: &amp;ValueType) {
    let mut buf = Vec::new();
		buf.extend_from_slice(b&quot;exchildtr&quot;);
		buf.extend_from_slice(&amp;index.to_le_bytes()[..]);

	let id = CHILD_STORAGE_KEY_PREFIX.into_iter()
        .chain(b&quot;default:&quot;)
        .chain(T::Hashing::hash(&amp;buf[..]).as_ref().into_iter())
        .cloned()
        .collect();

	who.using_encoded(|b| child::put(id.as_ref(), b, value_type));
}
</code></pre>
<p>The code in <a href="https://github.com/substrate-developer-hub/recipes/tree/master/pallets/child-trie"><code>pallets/child-trie</code></a> demonstrates a minimal way of organizing the basic child-trie api methods (as done in <a href="https://github.com/paritytech/polkadot/blob/c003d73c65cdcc0367340db09522c91d1d3851fc/runtime/common/src/crowdfund.rs"><code>polkadot/runtime/crowdfund</code></a>). It separates out the generation of the child trie id from the index with a runtime method <code>id_from_index</code>.</p>
<pre><code class="language-rust ignore">pub fn id_from_index(index: ObjectCount) -&gt; Vec&lt;u8&gt; {
    let mut buf = Vec::new();
    buf.extend_from_slice(b&quot;exchildtr&quot;);
    buf.extend_from_slice(&amp;index.to_le_bytes()[..]);

    CHILD_STORAGE_KEY_PREFIX
        .into_iter()
        .chain(b&quot;default:&quot;)
        .chain(Blake2Hasher::hash(&amp;buf[..]).as_ref().into_iter())
        .cloned()
        .collect()
}
</code></pre>
<p>This results in less code for each method:</p>
<pre><code class="language-rust ignore">pub fn kv_put(index: ObjectCount, who: &amp;T::AccountId, value_type: ValueType) {
    let id = Self::id_from_index(index);
    who.using_encoded(|b| child::put(id.as_ref(), b, &amp;value_type));
}
</code></pre>
<h2><a class="header" href="#smpl-crowdfund-a-name--smplcrwda" id="smpl-crowdfund-a-name--smplcrwda">smpl-crowdfund <a name = "smplcrwd"></a></a></h2>
<p><em><a href="https://github.com/substrate-developer-hub/recipes/tree/master/pallets/simple-crowdfund"><code>pallets/simple-crowdfund</code></a></em></p>
<p>Child tries are useful for batch deletion of <code>(key, value)</code> pairs associated with a specific <code>trie_id</code>. This is relevant to the <a href="https://github.com/paritytech/polkadot/blob/master/runtime/common/src/crowdfund.rs">polkadot/crowdfund</a> pallet, which tracks <code>(AccountId, BalanceOf&lt;T&gt;)</code> associated with a specific crowdfund. <code>BalanceOf&lt;T&gt;</code> represents the contributions of an <code>AccountId</code>. The identifier for each crowdfund is defined</p>
<pre><code class="language-rust ignore">type FundIndex = u32
</code></pre>
<p>With these three types, this storage item effectively manages <code>(FundIndex, AccountId, BalanceOf&lt;T&gt;)</code>. By maintaining a separate <code>child</code> for every <code>FundIndex</code>, this api allows for efficient batch deletions when crowdfunds are ended and dissolved.</p>
<pre><code class="language-rust ignore">// polkadot/runtime/crowdfund
pub fn crowdfund_kill(index: FundIndex) {
    let id = Self::id_from_index(index);
    child::kill_storage(id.as_ref());
}
</code></pre>
<p>The child trie api is useful when data associated with an identifier needs to be isolated to facilitate efficient batch removal. In this case, all the information associated with a given crowdfund should be removed when the crowdfund is dissolved.</p>
<h3><a class="header" href="#caveat-coder" id="caveat-coder">caveat coder</a></h3>
<p>Each individual call to read/write to the child trie is more expensive than it would be for <code>map</code> or <code>double_map</code>. This cost is poorly amortized over a large number of calls, but can be significantly reduced by following a proper batch execution strategy.</p>
<h1><a class="header" href="#using-and-storing-structs" id="using-and-storing-structs">Using and Storing Structs</a></h1>
<p><em><a href="https://github.com/substrate-developer-hub/recipes/tree/master/pallets/struct-storage"><code>pallets/struct-storage</code></a></em></p>
<p>In Rust, a <code>struct</code>, or structure, is a custom data type that lets you name and package together multiple related values that make up a meaningful group. If you’re familiar with an object-oriented language, a <code>struct</code> is like an object’s data attributes (read more in <a href="https://doc.rust-lang.org/book/ch05-01-defining-structs.html">The Rust Book</a>).</p>
<h2><a class="header" href="#defining-a-struct" id="defining-a-struct">Defining a Struct</a></h2>
<p>To define a <em>simple</em> custom struct for the runtime, the following syntax may be used:</p>
<pre><code class="language-rust ignore">#[derive(Encode, Decode, Default, Clone, PartialEq)]
pub struct MyStruct {
    some_number: u32,
    optional_number: Option&lt;u32&gt;,
}
</code></pre>
<p>In the code snippet above, the <a href="https://doc.rust-lang.org/rust-by-example/trait/derive.html">derive macro</a> is declared to ensure <code>MyStruct</code> conforms to shared behavior according to the specified <a href="https://doc.rust-lang.org/book/ch10-02-traits.html">traits</a>: <code>Encode, Decode, Default, Clone, PartialEq</code>. If you wish the store this struct in blockchain storage, you will need to derive (or manually ipmlement) each of these traits.</p>
<p>To use the <code>Encode</code> and <code>Decode</code> traits, it is necessary to import them.</p>
<pre><code class="language-rust ignore">use frame_support::codec::{Encode, Decode};
</code></pre>
<h2><a class="header" href="#structs-with-generic-fields" id="structs-with-generic-fields">Structs with Generic Fields</a></h2>
<p>The simple struct shown earlier only uses Rust primitive types for its fields. In the common case where you want to store types that come from your pallet's configuration trait (or the configuration trait of another pallet in your runtime), you must use generic type parameters in your struct's definition.</p>
<pre><code class="language-rust ignore">#[derive(Encode, Decode, Clone, Default, RuntimeDebug)]
pub struct InnerThing&lt;Hash, Balance&gt; {
	number: u32,
	hash: Hash,
	balance: Balance,
}
</code></pre>
<p>Here you can see that we want to store items of type <code>Hash</code> and <code>Balance</code> in the struct. Because these types come from the system and balances pallets' configuration traits, we must specify them as generics when declaring the struct.</p>
<p>It is often convenient to make a type alias that takes <code>T</code>, your pallet's configuration trait, as a single type parameter. Doing so simply saves you typing in the future.</p>
<pre><code class="language-rust ignore">type InnerThingOf&lt;T&gt; = InnerThing&lt;&lt;T as system::Trait&gt;::Hash, &lt;T as balances::Trait&gt;::Balance&gt;;
</code></pre>
<h2><a class="header" href="#structs-in-storage" id="structs-in-storage">Structs in Storage</a></h2>
<p>Using one of our structs as a storage item is not significantly different than using a primitive type. When using a generic struct, we must supply all of the generic type parameters. This snippet shows how to supply thos parameters when you have a type alias (like we do for <code>InnerThing</code>) as well as when you don't. Whether to include the type alias is a matter of style and taste, but it is generally preferred when the entire type exceeds the preferred line length.</p>
<pre><code class="language-rust ignore">decl_storage! {
	trait Store for Module&lt;T: Trait&gt; as NestedStructs {
		InnerThingsByNumbers get(fn inner_things_by_numbers):
			map hasher(blake2_256) u32 =&gt; InnerThingOf&lt;T&gt;;
		SuperThingsBySuperNumbers get(fn super_things_by_super_numbers):
			map hasher(blake2_256) u32 =&gt; SuperThing&lt;T::Hash, T::Balance&gt;;
	}
}
</code></pre>
<p>Interacting with the storage maps is now exactly as it was when we didn't use any custom structs</p>
<pre><code class="language-rust ignore">fn insert_inner_thing(origin, number: u32, hash: T::Hash, balance: T::Balance) -&gt; DispatchResult {
	let _ = ensure_signed(origin)?;
	let thing = InnerThing {
					number,
					hash,
					balance,
				};
	&lt;InnerThingsByNumbers&lt;T&gt;&gt;::insert(number, thing);
	Self::deposit_event(RawEvent::NewInnerThing(number, hash, balance));
	Ok(())
}
</code></pre>
<h2><a class="header" href="#nested-structs" id="nested-structs">Nested Structs</a></h2>
<p>Structs can also contain other structs as their fields. We have demonstrated this with the type <code>SuperThing</code>. As you see, any generic types needed by the inner struct must also be supplied to the outer.</p>
<pre><code class="language-rust ignore">#[derive(Encode, Decode, Default, RuntimeDebug)]
pub struct SuperThing&lt;Hash, Balance&gt; {
	super_number: u32,
	inner_thing: InnerThing&lt;Hash, Balance&gt;,
}
</code></pre>
<h1><a class="header" href="#basic-token" id="basic-token">Basic Token</a></h1>
<p><em><a href="https://github.com/substrate-developer-hub/recipes/tree/master/pallets/constant-config"><code>pallets/constant-config</code></a></em></p>
<p>This recipe demonstrates a simple but functional token in a pallet.</p>
<h2><a class="header" href="#mapping-accounts-to-balances" id="mapping-accounts-to-balances">Mapping Accounts to Balances</a></h2>
<p>Mappings are a very powerful primitive. A <em>stateful</em> cryptocurrency might store a mapping between accounts and balances. Likewise, mappings prove useful when representing <em>owned</em> data. By tracking ownership with maps, it is easy manage permissions for modifying values specific to individual users or groups.</p>
<h2><a class="header" href="#storage-items" id="storage-items">Storage Items</a></h2>
<p>The primary storage item is the mapping between AccountIds and Balances described above. Every account that holds tokens appears as a key in that map and its value is the number of tokens it holds.</p>
<p>The next two storage items set the total supply of the token and keep track of whether the token has been initialized yet.</p>
<pre><code class="language-rust ignore">decl_storage! {
	trait Store for Module&lt;T: Trait&gt; as Token {
		pub Balances get(get_balance): map hasher(blake2_256) T::AccountId =&gt; u64;

		pub TotalSupply get(total_supply): u64 = 21000000;

		Init get(is_init): bool;
	}
}
</code></pre>
<h2><a class="header" href="#events-and-errors" id="events-and-errors">Events and Errors</a></h2>
<p>The pallet defines events and errors for common lifecycle events such as successful and failed transfers, and successful and failed initialization.</p>
<pre><code class="language-rust ignore">decl_event!(
	pub enum Event&lt;T&gt;
	where
		AccountId = &lt;T as system::Trait&gt;::AccountId,
	{
		/// Token was initialized by user
		Initialized(AccountId),
		/// Tokens successfully transferred between users
		Transfer(AccountId, AccountId, u64), // (from, to, value)
	}
);

decl_error! {
	pub enum Error for Module&lt;T: Trait&gt; {
		/// Attempted to initialize the token after it had already been initialized.
		AlreadyInitialized,
		/// Attempted to transfer more funds than were available
		InsufficientFunds,
	}
}
</code></pre>
<h2><a class="header" href="#initializing-the-token" id="initializing-the-token">Initializing the Token</a></h2>
<p>In order for the token to be useful, some accounts need to own it. There are many possible ways to initialize a token including genesis config, claims process, lockdrop, and many more. This pallet will use a simple process where the first user to call the <code>init</code> function receives all of the funds. The total supply is hard-coded in the pallet in a fairly naive way: It is specified as the default value in the <code>decl_storage!</code> block.</p>
<pre><code class="language-rustignore">fn init(origin) -&gt; DispatchResult {
	let sender = ensure_signed(origin)?;
	ensure!(Self::is_init() == false, &lt;Error&lt;T&gt;&gt;::AlreadyInitialized);

	&lt;Balances&lt;T&gt;&gt;::insert(sender, Self::total_supply());

	Init::put(true);
	Ok(())
}
</code></pre>
<p>As usual, we first check for preconditions. I this case that means making sure that the token is not already initialized. Then we do any mutation necessary.</p>
<h2><a class="header" href="#transferring-tokens" id="transferring-tokens">Transferring Tokens</a></h2>
<p>To transfer tokens, a user who owns some tokens calls the <code>transfer</code> method specifying the recipient and the amount of tokens to transfer as parameters.</p>
<p>We again check for error conditions before mutating storage. In this case it is <em>not</em> necessary to check whether the token has been initialized. If it has not, nobody has any funds and the transfer will simply fail with <code>InsufficientFunds</code>.</p>
<pre><code class="language-rust ignore">/// Transfer tokens from one account to another
fn transfer(_origin, to: T::AccountId, value: u64) -&gt; DispatchResult {
	let sender = ensure_signed(_origin)?;
	let sender_balance = Self::get_balance(&amp;sender);
	let receiver_balance = Self::get_balance(&amp;to);

	// Calculate new balances
	let updated_from_balance = sender_balance.checked_sub(value).ok_or(&lt;Error&lt;T&gt;&gt;::InsufficientFunds)?;
	let updated_to_balance = receiver_balance.checked_add(value).expect(&quot;Entire supply fits in u64; qed&quot;);

	// Write new balances to storage
	&lt;Balances&lt;T&gt;&gt;::insert(&amp;sender, updated_from_balance);
	&lt;Balances&lt;T&gt;&gt;::insert(&amp;to, updated_to_balance);

	Self::deposit_event(RawEvent::Transfer(sender, to, value));
	Ok(())
}
</code></pre>
<p>Here we notice the peculiar syntax of <code>.expect</code>. Because you must never panic in a runtime function, it is considered good style to use the <code>expect</code> method and provide a proof of why the panic will never happen.</p>
<h1><a class="header" href="#configurable-pallet-constants" id="configurable-pallet-constants">Configurable Pallet Constants</a></h1>
<p><em><a href="https://github.com/substrate-developer-hub/recipes/tree/master/pallets/constant-config"><code>pallets/constant-config</code></a></em></p>
<p>To declare constant values within a runtime, it is necessary to import the <a href="https://substrate.dev/rustdocs/master/frame_support/traits/trait.Get.html"><code>Get</code></a> trait from <code>frame_support</code></p>
<pre><code class="language-rust ignore">use support::traits::Get;
</code></pre>
<p>Configurable constants are declared as associated types in the pallet's <code>pub trait Trait</code> block using the <code>Get&lt;T&gt;</code> syntax for any type <code>T</code>.</p>
<pre><code class="language-rust ignore">pub trait Trait: system::Trait {
	type Event: From&lt;Event&gt; + Into&lt;&lt;Self as system::Trait&gt;::Event&gt;;

    type Currency: Currency&lt;Self::AccountId&gt; + ReservableCurrency&lt;Self::AccountId&gt;;

    type MaxAddend: Get&lt;u32&gt;;

    // frequency with which the this value is deleted
    type ClearFrequency: Get&lt;Self::BlockNumber&gt;;
}
</code></pre>
<p>In order to make these constants accessible within the pallet, it is necessary to declare them with the <code>const</code> syntax in the <code>decl_module</code> block. Usually constants are declared at the top of this block, under <code>fn deposit_event</code>.</p>
<pre><code class="language-rust ignore">decl_module! {
    pub struct Module&lt;T: Trait&gt; for enum Call where origin: T::Origin {
		fn deposit_event() = default;

        const MaxAddend: u32 = T::MaxAddend::get();

        const ClearFrequency: T::BlockNumber = T::ClearFrequency::get();
    }
}
</code></pre>
<p>This example manipulates a single value in storage declared as <code>SingleValue</code>.</p>
<pre><code class="language-rust ignore">decl_storage! {
	trait Store for Module&lt;T: Trait&gt; as Example {
        SingleValue get(fn single_value): u32;
	}
}
</code></pre>
<p><code>SingleValue</code> is set to <code>0</code> every <code>ClearFrequency</code> number of blocks in the <code>on_finalize</code> function that runs at the end of blocks execution.</p>
<pre><code class="language-rust ignore">fn on_finalize(n: T::BlockNumber) {
    if (n % T::ClearFrequency::get()).is_zero() {
        let c_val = &lt;SingleValue&gt;::get();
        &lt;SingleValue&gt;::put(0u32); // is this cheaper than killing?
        Self::deposit_event(Event::Cleared(c_val));
    }
}
</code></pre>
<p>Signed transactions may invoke the <code>add_value</code> runtime method to increase <code>SingleValue</code> as long as each call adds less than <code>MaxAddend</code>. <em>There is no anti-sybil mechanism so a user could just split a larger request into multiple smaller requests to overcome the <code>MaxAddend</code></em>, but overflow is still handled appropriately.</p>
<pre><code class="language-rust ignore">fn add_value(origin, val_to_add: u32) -&gt; Result {
    let _ = ensure_signed(origin)?;
    ensure!(val_to_add &lt;= T::MaxAddend::get(), &quot;value must be &lt;= maximum add amount constant&quot;);

    // previous single value
    let c_val = &lt;SingleValue&gt;::get();

    // checks for overflow
    let result = match c_val.checked_add(val_to_add) {
        Some(r) =&gt; r,
        None =&gt; return Err(&quot;Addition overflowed&quot;),
    };
    &lt;SingleValue&gt;::put(result);
    Self::deposit_event(Event::Added(c_val, val_to_add, result));
    Ok(())
}
</code></pre>
<p>In more complex patterns, the constant value may be used as a static, base value that is scaled by a multiplier to incorporate stateful context for calculating some dynamic fee (ie floating transaction fees).</p>
<p>To test the range of pallet configurations introduced by configurable constants, see <em><a href="3-entrees/./testing/externalities.html">custom configuration of externalities</a></em></p>
<h1><a class="header" href="#instantiable-pallets" id="instantiable-pallets">Instantiable Pallets</a></h1>
<p><em><a href="https://github.com/substrate-developer-hub/recipes/tree/master/pallets/last-caller"><code>pallets/last-caller</code></a></em> <em><a href="https://github.com/substrate-developer-hub/recipes/tree/master/pallets/default-instance"><code>pallets/default-instance</code></a></em></p>
<p>Instantiable pallets enable multiple instances of the same pallet logic within a single runtime. Each instance of the pallet has its own independent storage, and extrinsics must specify which instance of the pallet they are intended for. These patterns are illustrated in the kitchen in the last-caller and default-instance pallets.</p>
<p>Some use cases:</p>
<ul>
<li>Token chain hosts two independent cryptocurrencies.</li>
<li>Marketplace track users' reputations as buyers separately from their reputations as sellers.</li>
<li>Governance has two (or more) houses which act similarly internally.</li>
</ul>
<p>Substrate's own Balances and Collective pallets are good examples of real-world code using this technique. The default Substrate node has two instances of the Collectives pallet that make up its Council and Technical Committee. Each collective has its own storage, events, and configuration.</p>
<pre><code class="language-rust ignore">Council: collective::&lt;Instance1&gt;::{Module, Call, Storage, Origin&lt;T&gt;, Event&lt;T&gt;, Config&lt;T&gt;},
TechnicalCommittee: collective::&lt;Instance2&gt;::{Module, Call, Storage, Origin&lt;T&gt;, Event&lt;T&gt;, Config&lt;T&gt;}
</code></pre>
<h2><a class="header" href="#writing-an-instantiable-pallet" id="writing-an-instantiable-pallet">Writing an Instantiable Pallet</a></h2>
<p>Writing an instantiable pallet is almost entirely the same process as writing a plain non-instantiable pallet. There are just a few places where the syntax differs.</p>
<blockquote>
<p>You must call <code>decl_storage!</code></p>
<p>Instantiable pallets <em>must</em> call the <code>decl_storage!</code> macro so that the <code>Instance</code> type is created.</p>
</blockquote>
<h3><a class="header" href="#configuration-trait-1" id="configuration-trait-1">Configuration Trait</a></h3>
<pre><code class="language-rust ignore">pub trait Trait&lt;I: Instance&gt;: system::Trait {
	/// The overarching event type.
	type Event: From&lt;Event&lt;Self, I&gt;&gt; + Into&lt;&lt;Self as system::Trait&gt;::Event&gt;;
}
</code></pre>
<h3><a class="header" href="#storage-declaration" id="storage-declaration">Storage Declaration</a></h3>
<pre><code class="language-rust ignore">decl_storage! {
	trait Store for Module&lt;T: Trait&lt;I&gt;, I: Instance&gt; as TemplatePallet {
		...
	}
}
</code></pre>
<h3><a class="header" href="#declaring-the-module-struct" id="declaring-the-module-struct">Declaring the <code>Module</code> Struct</a></h3>
<pre><code class="language-rust ignore">decl_module! {
	/// The module declaration.
	pub struct Module&lt;T: Trait&lt;I&gt;, I: Instance&gt; for enum Call where origin: T::Origin {
		...
	}
}
</code></pre>
<h3><a class="header" href="#accessing-storage" id="accessing-storage">Accessing Storage</a></h3>
<pre><code class="language-rust ignore">&lt;Something&lt;T, I&gt;&gt;::put(something);
</code></pre>
<p>If the storage item does not use any types specified in the configuration trait, the T is omitted, as always.</p>
<pre><code class="language-rust ignore">&lt;Something&lt;I&gt;&gt;::put(something);
</code></pre>
<h3><a class="header" href="#event-initialization" id="event-initialization">Event initialization</a></h3>
<pre><code class="language-rust ignore">fn deposit_event() = default;
</code></pre>
<h3><a class="header" href="#event-declaration" id="event-declaration">Event Declaration</a></h3>
<pre><code class="language-rust ignore">decl_event!(
	pub enum Event&lt;T, I&gt; where AccountId = &lt;T as system::Trait&gt;::AccountId {
		...
	}
}
</code></pre>
<h2><a class="header" href="#installing-a-pallet-instance-in-a-runtime" id="installing-a-pallet-instance-in-a-runtime">Installing a Pallet Instance in a Runtime</a></h2>
<p>The syntax for including an instance of an instantiable pallet in a runtime is slightly different than for a regular pallet. The only exception is for pallets that use the <a href="3-entrees/instantiable.html#default-instance">Default Instance</a> feature described below.</p>
<h3><a class="header" href="#implementing-configuration-traits" id="implementing-configuration-traits">Implementing Configuration Traits</a></h3>
<p>Each instance needs to be configured separately. Configuration consists of implementing the specific instance's trait. The following snippet shows a configuration for <code>Instance1</code>.</p>
<pre><code class="language-rust ignore">impl template::Trait&lt;template::Instance1&gt; for Runtime {
	type Event = Event;
}
</code></pre>
<h3><a class="header" href="#using-the-construct_runtime-macro" id="using-the-construct_runtime-macro">Using the <code>construct_runtime!</code> Macro</a></h3>
<p>The final step of installing the pallet instance in your runtime is updating the <code>construct_runtime!</code> macro. You may give each instance a meaningful name. Here I've called <code>Instance1</code> <code>FirstTemplate</code>.</p>
<pre><code class="language-rust ignore">FirstTemplate: template::&lt;Instance1&gt;::{Module, Call, Storage, Event&lt;T&gt;, Config},
</code></pre>
<h2><a class="header" href="#default-instance-a-namedefault-instancea" id="default-instance-a-namedefault-instancea">Default Instance <a name="default-instance"></a></a></h2>
<p>One drawback of instantiable pallets, as we've presented them so far, is that they require the runtime designer to use the more elaborate syntax even if they only desire a single instance of the pallet. To alleviate this inconvenience, Substrate provides a feature known as DefaultInstance. This allows runtime developers to deploy an instantiable pallet exactly as they would if it were not instantiable provided they <strong>only use a single instance</strong>.</p>
<p>To make your instantiable pallet support DefaultInstance, you must specify it in four places.</p>
<pre><code class="language-rust ignore">pub trait Trait&lt;I=DefaultInstance&gt;: system::Trait {
</code></pre>
<pre><code class="language-rust ignore">decl_storage! {
  trait Store for Module&lt;T: Trait&lt;I&gt;, I: Instance=DefaultInstance&gt; as TemplateModule {
    ...
  }
}
</code></pre>
<pre><code class="language-rust ignore">decl_module! {
    pub struct Module&lt;T: Trait&lt;I&gt;, I: Instance = DefaultInstance&gt; for enum Call where origin: T::Origin {
        ...
    }
}
</code></pre>
<pre><code class="language-rust ignore">decl_event!(
	pub enum Event&lt;T, I=DefaultInstance&gt; where ... {
    ...
  }
}
</code></pre>
<p>Having made these changes, a developer who uses your pallet doesn't need to know or care that your pallet is instantable. They can deploy it just as they would any other pallet.</p>
<h2><a class="header" href="#genesis-configuration" id="genesis-configuration">Genesis Configuration</a></h2>
<p>Some pallets require a genesis configuration to be specified. Let's look to the default Substrate node's use of the Collective pallet as an example.</p>
<p>In its <code>chain_spec.rs</code> file we see</p>
<pre><code class="language-rust ignore">GenesisConfig {
	...
	collective_Instance1: Some(CouncilConfig {
		members: vec![],
		phantom: Default::default(),
	}),
	collective_Instance2: Some(TechnicalCommitteeConfig {
		members: vec![],
		phantom: Default::default(),
	}),
	...
}
</code></pre>
<h1><a class="header" href="#computational-resources-and-weights" id="computational-resources-and-weights">Computational Resources and Weights</a></h1>
<p><em><a href="https://github.com/substrate-developer-hub/recipes/tree/master/pallets/weights"><code>pallets/weights</code></a></em></p>
<p>Any computational resources used by a transaction must be accounted for so that appropriate fees can be applied, and it is a pallet author's job to ensure that this accounting happens. Substrate provides a mechanism known as transaction weighting to quantify the resources consumed while executing a transaction.</p>
<p><em>Indeed, mispriced EVM operations have shown how operations that underestimate cost can open economic DOS attack vectors: <a href="https://www.parity.io/onwards/">Onwards; Underpriced EVM Operations</a>, <a href="https://www4.comp.polyu.edu.hk/%7Ecsxluo/DoSEVM.pdf">Under-Priced DOS Attacks on Ethereum</a></em></p>
<h2><a class="header" href="#assigning-transaction-weights" id="assigning-transaction-weights">Assigning Transaction Weights</a></h2>
<p>Pallet authors can annotate their dispatchable function with a weight using syntax like this,</p>
<pre><code class="language-rust ignore">#[weight = &lt;Some Weighting Instance&gt;]
fn some_call(...) -&gt; Result {
	// --snip--
}
</code></pre>
<p>For simple transactions a fixed weight will do. Substrate provides the <a href="https://substrate.dev/rustdocs/master/frame_support/weights/enum.SimpleDispatchInfo.html"><code>SimpleDispatchInfo</code> enum</a> for situations like this.</p>
<pre><code class="language-rust ignore">decl_module! {
	pub struct Module&lt;T: Trait&gt; for enum Call {

		#[weight = SimpleDispatchInfo::FixedNormal(100)]
		fn store_value(_origin, entry: u32) -&gt; Result {
			// --snip--
		}
</code></pre>
<p>For more complex transactions, custom weight calculations can be performed that consider the parameters passed to the call. This snippet shows a weighting struct that weighs transactions where the first parameter
is a <code>boo</code>l. If the first parameter is <code>true</code>, then the weight is linear in the second parameter. Otherwise the weight is constant. A transaction where this weighting scheme makes sense is demonstrated in the kitchen.</p>
<pre><code class="language-rust ignore">pub struct Conditional(u32);

impl WeighData&lt;(&amp;bool, &amp;u32)&gt; for Conditional {
	fn weigh_data(&amp;self, (switch, val): (&amp;bool, &amp;u32)) -&gt; Weight {

		if *switch {
			val.saturating_mul(self.0)
		}
		else {
			self.0
		}
	}
}
</code></pre>
<p>In addition to the <a href="https://substrate.dev/rustdocs/master/frame_support/weights/trait.WeighData.html"><code>WeightData</code>
Trait</a>, shown
above, types that are used to calculate transaction weights, must also implement
<a href="https://substrate.dev/rustdocs/master/frame_support/weights/trait.ClassifyDispatch.html"><code>ClassifyDispatch</code></a>,
and <a href="https://substrate.dev/rustdocs/master/frame_support/weights/trait.PaysFee.html"><code>PaysFee</code></a>.</p>
<pre><code class="language-rust ignore">impl&lt;T&gt; ClassifyDispatch&lt;T&gt; for Conditional {
    fn classify_dispatch(&amp;self, _: T) -&gt; DispatchClass {
        // Classify all calls as Normal (which is the default)
        Default::default()
    }
}
</code></pre>
<pre><code class="language-rust ignore">impl PaysFee for Conditional {
    fn pays_fee(&amp;self) -&gt; bool {
        true
    }
}
</code></pre>
<p>The complete code for this example as well as several others can be found in the kitchen.</p>
<h2><a class="header" href="#cautions" id="cautions">Cautions</a></h2>
<p>While you can make reasonable estimates of resource consumption at
design time, it is always best to actually measure the resources
required of your functions through an empirical process. Failure to
perform such rigorous measurement may result in an economically
insecure chain.</p>
<p>While it isn't enforced, calculating a transaction's weight should itself be a cheap operation. If the weight calculation itself is expensive, your chain will be insecure.</p>
<h2><a class="header" href="#what-about-fees" id="what-about-fees">What About Fees?</a></h2>
<p>Weights are used only to describe the computational resources consumed by a transaction, and enable accounting of these resources. To learn how to turn these weights into actual fees charged to transactors, continue to the recipe on <a href="3-entrees/./fees.html">Fees</a>.</p>
<h1><a class="header" href="#transaction-fees" id="transaction-fees">Transaction Fees</a></h1>
<p><em><a href="https://github.com/substrate-developer-hub/recipes/tree/master/runtimes/weight-fee-runtime">runtimes/weight-fee-runtime</a></em></p>
<p>Substrate provides the <a href="https://substrate.dev/rustdocs/master/pallet_transaction_payment/index.html"><code>transaction_payment</code> pallet</a> for calculating and collecting fees for executing transactions. Fees are broken down into several components:</p>
<ul>
<li>Base fee - A fixed fee applied to each transaction. A parameter in the <code>transaction_payment</code> pallet.</li>
<li>Length fee - A fee proportional to the transaction's length in bytes. The proportionality constant is a parameter in the <code>transaction_payment</code> pallet.</li>
<li>Weight fee - A fee calculated from the transaction's weight. Weights are intended to capture the actual resources consumed by the transaction. Learn more in the <a href="3-entrees/./weights.html">recipe on weights</a>. It doesn't need to be linear, although it often is. The same conversion function is applied across all transactions from all pallets in the runtime.</li>
<li>Fee Multiplier - A multiplier for the computed fee, that can change as the chain progresses. This topic is not (yet) covered further in the recipes.</li>
</ul>
<p><code>total_fee = base_fee + transaction_length * length_fee + weight_to_fee(total_weight)</code></p>
<h2><a class="header" href="#setting-the-constants" id="setting-the-constants">Setting the Constants</a></h2>
<p>Each of the parameters described above is set in the <code>transaction_payment</code> pallet's configuration trait. For example, the <code>super-runtime</code> sets these parameters as follows.</p>
<pre><code class="language-rust ignore">parameter_types! {
    pub const TransactionBaseFee: u128 = 0;
    pub const TransactionByteFee: u128 = 1;
}

impl transaction_payment::Trait for Runtime {
    type Currency = balances::Module&lt;Runtime&gt;;
    type OnTransactionPayment = ();
    type TransactionBaseFee = TransactionBaseFee;
    type TransactionByteFee = TransactionByteFee;
    type WeightToFee = ConvertInto;
    type FeeMultiplierUpdate = ();
}
</code></pre>
<h2><a class="header" href="#converting-weight-to-fees" id="converting-weight-to-fees">Converting Weight To Fees</a></h2>
<p>In many cases converting weight to fees 1:1, as shown above, will suffice and can be accomplished with <a href="https://substrate.dev/rustdocs/master/sp_runtime/traits/struct.ConvertInto.html"><code>ConvertInto</code></a>. This approach is also taken in the <a href="https://github.com/substrate-developer-hub/substrate-node-template/blob/43ee95347b6626580b1d9d554c3c8b77dc85bc01/runtime/src/lib.rs#L230">node template</a>. It is also possible to provide a type that makes a more complex calculation. Any type that implements <code>Convert&lt;Weight, Balance&gt;</code> will suffice.</p>
<p>This example uses a quadratic conversion and supports custom coefficients</p>
<pre><code class="language-rust ignore">pub struct QuadraticWeightToFee&lt;C0, C1, C2&gt;(C0, C1, C2);

impl&lt;C0, C1, C2&gt; Convert&lt;Weight, Balance&gt; for QuadraticWeightToFee&lt;C0, C1, C2&gt;
	where C0: Get&lt;Balance&gt;, C1: Get&lt;Balance&gt;, C2: Get&lt;Balance&gt; {

	fn convert(w: Weight) -&gt; Balance {
		let c0 = C0::get();
		let c1 = C1::get();
		let c2 = C2::get();
		let w = Balance::from(w);

		// TODO use safe math
		c0 + c1 * w + c2 * w * w
	}
}
</code></pre>
<p>This examples, and several others can be compiled in the kitchen's <a href="https://github.com/substrate-developer-hub/recipes/tree/master/runtimes/weight-fee-runtime">weight-fee-runtime</a></p>
<h2><a class="header" href="#collecting-fees" id="collecting-fees">Collecting Fees</a></h2>
<p>Having calculated the amount of fees due, runtime authors must decide which asset the fees should be paid in. A common choice is the use the <a href="https://substrate.dev/rustdocs/master/pallet_balances/index.html"><code>Ballances</code> pallet</a>, but any type that implements the <a href="https://substrate.dev/rustdocs/master/frame_support/traits/trait.Currency.html"><code>Currency</code> trait</a> can be used. The weight-fee-runtime demonstrates how to use an asset provided by the <a href="https://substrate.dev/rustdocs/master/pallet_generic_asset/index.html"><code>Generic Asset</code> pallet</a>.</p>
<pre><code class="language-rust ignore">impl transaction_payment::Trait for Runtime {

	// A generic asset whose ID is stored in the generic_asset pallet's runtime storage
	type Currency = SpendingAssetCurrency&lt;Self&gt;;

	// --snip--
}
</code></pre>
<p>This examples, and several others can be compiled in the kitchen's <a href="https://github.com/substrate-developer-hub/recipes/tree/master/runtimes/weight-fee-runtime">weight-fee-runtime</a></p>
<h1><a class="header" href="#charity" id="charity">Charity</a></h1>
<p><em><a href="https://github.com/substrate-developer-hub/recipes/tree/master/pallets/charity"><code>pallets/charity</code></a></em></p>
<p>The Charity pallet represents a simple charitable organization that collects funds into a pot that it controls, and allocates those funds to the appropriate causes. It demonstrates two useful concepts in Substrate development:</p>
<ul>
<li>A pallet-controlled shared pot of funds</li>
<li>Absorbing imbalances from the runtime</li>
</ul>
<h2><a class="header" href="#instantiate-a-pot" id="instantiate-a-pot">Instantiate a Pot</a></h2>
<p>Our charity needs an acocunt to hold its funds. Unlike other acocunts, it will not be controlled by a user's cryptographic key pair, but directly by the pallet. To instantiate such a pool of funds, import <a href="https://substrate.dev/rustdocs/master/sp_runtime/struct.ModuleId.html"><code>ModuleId</code></a> and <a href="https://substrate.dev/rustdocs/master/sp_runtime/traits/trait.AccountIdConversion.html"><code>AccountIdConversion</code></a> from <a href="https://substrate.dev/rustdocs/master/sp_runtime/index.html"><code>sp-runtime</code></a>.</p>
<pre><code class="language-rust ignore">use sp-runtime::{ModuleId, traits::AccountIdConversion};
</code></pre>
<p>With these imports, a <code>PALLET_ID</code> constant can be generated as an identifier for the pool of funds. The <code>PALLET_ID</code> must be exactly eight characters long which is why we've included the exclamation point. (Well, that and Charity work is just so exciting!) This identifier can be converted into an <code>AccountId</code> with the <code>into_account()</code> method provided by the <code>AccountIdConversion</code> trait.</p>
<pre><code class="language-rust ignore">const PALLET_ID: ModuleId = ModuleId(*b&quot;Charity!&quot;);

impl&lt;T: Trait&gt; Module&lt;T&gt; {
    /// The account ID that holds the Charity's funds
    pub fn account_id() -&gt; T::AccountId {
        PALLET_ID.into_account()
    }

    /// The Charity's balance
    fn pot() -&gt; BalanceOf&lt;T&gt; {
        T::Currency::free_balance(&amp;Self::account_id())
    }
}
</code></pre>
<h1><a class="header" href="#receiving-funds" id="receiving-funds">Receiving Funds</a></h1>
<p>Our charity can receive funds in two different ways.</p>
<h2><a class="header" href="#donations" id="donations">Donations</a></h2>
<p>The first and perhaps more familiar way is through charitable donations. Donations can be made through a standard <code>donate</code> extrinsic which accepts the amount to be donated as a parameter.</p>
<pre><code class="language-rust ignore">fn donate(
		origin,
		amount: BalanceOf&lt;T&gt;
) -&gt; DispatchResult {
		let donor = ensure_signed(origin)?;

		let _ = T::Currency::transfer(&amp;donor, &amp;Self::account_id(), amount, AllowDeath);

		Self::deposit_event(RawEvent::DonationReceived(donor, amount, Self::pot()));
		Ok(())
}
</code></pre>
<h2><a class="header" href="#imbalances" id="imbalances">Imbalances</a></h2>
<p>The second way the charity can receive funds is by absorbing imbalances created elsewhere in the runtime. An <a href="https://substrate.dev/rustdocs/master/frame_support/traits/trait.Imbalance.html"><code>Imbalance</code></a> is created whenever tokens are burned, or minted. Because our charity wants to <em>collect</em> funds, we are specifically interested in <a href="https://substrate.dev/rustdocs/master/pallet_balances/struct.NegativeImbalance.html"><code>NegativeImbalance</code></a>s. Negative imbalances are created, for example, when a validator is slashed for violating consensus rules, transaction fees are collected, or another pallet burns funds as part of an incentive-alignment mechanism. To allow our pallet to absorb these imbalances, we implement the <a href="https://substrate.dev/rustdocs/master/frame_support/traits/trait.OnUnbalanced.html"><code>OnUnbalanced</code> trait</a>.</p>
<pre><code class="language-rust ignore">use frame_support::traits::{OnUnbalanced, Imbalance};
type NegativeImbalanceOf&lt;T&gt; = &lt;&lt;T as Trait&gt;::Currency as Currency&lt;&lt;T as system::Trait&gt;::AccountId&gt;&gt;::NegativeImbalance;

impl&lt;T: Trait&gt; OnUnbalanced&lt;NegativeImbalanceOf&lt;T&gt;&gt; for Module&lt;T&gt; {
	fn on_nonzero_unbalanced(amount: NegativeImbalanceOf&lt;T&gt;) {
		let numeric_amount = amount.peek();

		// Must resolve into existing but better to be safe.
		let _ = T::Currency::resolve_creating(&amp;Self::account_id(), amount);

		Self::deposit_event(RawEvent::ImbalanceAbsorbed(numeric_amount, Self::pot()));
	}
}
</code></pre>
<h1><a class="header" href="#allocating-funds" id="allocating-funds">Allocating Funds</a></h1>
<p>In order for the charity to affect change with the funds it has collected it must be able to allocate those funds. Our charity pallet abstracts the governance of where funds will be allocated to the rest of the runtime. Funds can be allocated by a root call to the <code>allocate</code> extrinsic. One good example of a governance mechanism for such decisions is Substrate's own <a href="https://substrate.dev/rustdocs/master/pallet_democracy/index.html">Democracy pallet</a>.</p>
<h1><a class="header" href="#runtime-apis" id="runtime-apis">Runtime APIs</a></h1>
<p><em><a href="https://github.com/substrate-developer-hub/recipes/tree/master/pallets/sum-storage"><code>pallets/sum-storage</code></a></em>
<em><a href="https://github.com/substrate-developer-hub/recipes/tree/master/runtimes/api-runtime"><code>runtimes/api-runtime</code></a></em></p>
<p>Each Substrate node contains a runtime. The runtime contains the business logic of the chain. It defines what transactions are valid and invalid and determines how the chain's state changes in response to transactions. The runtime is compiled to Wasm to facilitate runtime upgrades. The &quot;outer node&quot;, everything other than the runtime, does not compile to Wasm, only to native. The outer node is responsible for handling peer discovery, transaction pooling, block and transaction gossiping, consensus, and answering RPC calls from the outside world. While performing these tasks, the outer node sometimes needs to query the runtime for information, or provide information to the runtime. A Runtime API facilitates this communication between the outer node and the runtime. In this recipe, we will write our own minimal runtime API.</p>
<h2><a class="header" href="#our-example" id="our-example">Our Example</a></h2>
<p>For this example, we will write a pallet called <code>sum-storage</code> with two storage items, both <code>u32</code>s.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>decl_storage! {
	trait Store for Module&lt;T: Trait&gt; as TemplateModule {
		Thing1 get(fn thing1): Option&lt;u32&gt;;
		Thing2 get(fn thing2): Option&lt;u32&gt;;
	}
}
<span class="boring">}
</span></code></pre></pre>
<p>Substrate already comes with a runtime API for querying storage values, which is why we can easily query our two storage values from a front-end. In this example we imagine that the outer node is interested in knowing the <em>sum</em> of the two values, rather than either individual value. Our runtime API will provide a way for the outer node to query the inner node for this sum. Before we define the actual runtime API, let's write a public helper function to do the summing.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>impl&lt;T: Trait&gt; Module&lt;T&gt; {
	pub fn get_sum() -&gt; u32 {
		Thing1::get() + Thing2::get()
	}
}
<span class="boring">}
</span></code></pre></pre>
<p>So far, nothing we've done is specific to runtime APIs. In the coming sections, we will use this helper function in our runtime API's implementation.</p>
<h2><a class="header" href="#defining-the-api" id="defining-the-api">Defining the API</a></h2>
<p>The first step in adding a runtime API to your runtime is defining its interface using a Rust trait. This is done in the <code>sum-storage/rpc/runtime-api/src/lib.rs</code> file. This file can live anywhere you like, but because it defines an API that is closely related to a particular pallet, it makes sense to include the API definition in the pallet's directory.</p>
<blockquote>
<p>The <code>rpc</code> in the path is not relevant in <em>this</em> recipe, but it is explained in the recipe on <a href="3-entrees/./custom-rpc.html">custom RPCs</a>.</p>
</blockquote>
<p>The code to define the API is quite simple, and looks almost like any old Rust trait. The one addition is that it must be placed in the <a href="https://substrate.dev/rustdocs/master/sp_api/macro.decl_runtime_apis.html"><code>decl_runtime_apis!</code> macro</a>. This macro allows the outer node to query the runtime API at specific blocks. Although this runtime API only provides a single function, you may write as many as you like.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>sp_api::decl_runtime_apis! {
	pub trait SumStorageApi {
		fn get_sum() -&gt; u32;
	}
}
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#implementing-the-api" id="implementing-the-api">Implementing the API</a></h2>
<p>With our pallet written and our runtime API defined, we may now implement the API. This happens in the main runtime aggregation file. In our case we've provided the <code>api-runtime</code> in <code>runtimes/api-runtime/src/lib.rs</code>.</p>
<p>As with defining the API, implementing a runtime API looks similar to implementing any old Rust trait with the exception that the implementation must go inside of the <a href="https://substrate.dev/rustdocs/master/sp_api/macro.impl_runtime_apis.html"><code>impl_runtime_apis!</code> macro</a>. If you've started by copying an existing runtime like the <a href="https://github.com/substrate-developer-hub/substrate-node-template/">node template</a> you likely already have this block. We will add an implementation for our API to the existing block. Our implementation is straight-forward as it merely calls the pallet's helper function that we wrote previously.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>impl_runtime_apis! {
  // --snip--

  impl sum_storage_rpc_runtime_api::SumStorageApi&lt;Block&gt; for Runtime {
		fn get_sum() -&gt; u32 {
			SumStorage::get_sum()
		}
	}
}
<span class="boring">}
</span></code></pre></pre>
<p>You may be wondering about the <code>Block</code> type parameter which is present here, but not in our definition. This type parameter is added by the macros along with a few other features. All runtime APIs have the type parameter to facilitate querying the runtime at arbitrary blocks. Read more about this in the docs for <a href="https://substrate.dev/rustdocs/master/sp_api/macro.impl_runtime_apis.html"><code>impl_runtime_apis!</code></a>.</p>
<h2><a class="header" href="#calling-the-runtime-api" id="calling-the-runtime-api">Calling the Runtime API</a></h2>
<p>We've now successfully added a runtime API to our runtime. The outer node can now call this API to query the runtime for the sum of two storage values. Given a reference to a <a href="https://substrate.dev/rustdocs/master/sc_client/struct.Client.html">'client'</a> we can make the call like this.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>let sum_at_block_fifty = client.runtime_api().get_sum(&amp;50);
<span class="boring">}
</span></code></pre></pre>
<p>Calling this runtime API is described with much more detail and context in the recipe on <a href="3-entrees/./custom-rpc.html">custom RPCs</a>.</p>
<h1><a class="header" href="#custom-rpcs" id="custom-rpcs">Custom RPCs</a></h1>
<p><em><a href="https://github.com/substrate-developer-hub/recipes/tree/master/nodes/rpc-node"><code>nodes/rpc-node</code></a></em>
<em><a href="https://github.com/substrate-developer-hub/recipes/tree/master/runtimes/api-runtime"><code>runtime/api-runtime</code></a></em></p>
<p>Remote Procedure Calls, or RPCs, are a way for an external program (eg. a frontend) to communicate with a Substrate node. They are used for checking storage values, submitting transactions, and querying the current consensus authorities. Substrate comes with several <a href="https://polkadot.js.org/api/substrate/rpc.html">default RPCs</a>. In many cases it is useful to add custom RPCs to your node. In this recipe, we will add two custom RPCs to our node, one of which calls into a <a href="3-entrees/./runtime-api.html">custom runtime API</a>.</p>
<h2><a class="header" href="#defining-an-rpc" id="defining-an-rpc">Defining an RPC</a></h2>
<p>Every RPC that the node will use must be defined in a trait. We'll begin by defining a simple RPC
called &quot;silly rpc&quot; which just returns constant integers. A Hello world of sorts. In the <code>nodes/rpc-node/src/silly_rpc.rs</code> file, we define a basic rpc as</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>#[rpc]
pub trait SillyRpc {
    #[rpc(name = &quot;silly_seven&quot;)]
    fn silly_7(&amp;self) -&gt; Result&lt;u64&gt;;

    #[rpc(name = &quot;silly_double&quot;)]
    fn silly_double(&amp;self, val: u64) -&gt; Result&lt;u64&gt;;
}
<span class="boring">}
</span></code></pre></pre>
<p>This definition defines two RPC methods called <code>hello_five</code> and <code>hello_seven</code>. Each RPC method must take a <code>&amp;self</code> reference and must return a <code>Result</code>. Next, we define a struct that implements this trait.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>pub struct Silly;

impl SillyRpc for Silly {
    fn silly_7(&amp;self) -&gt; Result&lt;u64&gt; {
        Ok(7)
    }

    fn silly_double(&amp;self, val: u64) -&gt; Result&lt;u64&gt; {
        Ok(2 * val)
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Finally, to make the contents of this new files visible, we need to add a line in our <code>main.rs</code>.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>mod silly_rpc;
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#including-the-rpc" id="including-the-rpc">Including the RPC</a></h2>
<p>With our RPC written, we're ready to install it on our node. We begin with a few dependencies in our <code>rpc-node</code>'s <code>Cargo.toml</code>.</p>
<pre><code class="language-toml">jsonrpc-core = &quot;14.0.3&quot;
jsonrpc-core-client = &quot;14.0.3&quot;
jsonrpc-derive = &quot;14.0.3&quot;
sc-rpc = { git = 'https://github.com/paritytech/substrate.git', tag = 'v2.0.0-alpha.3' }
</code></pre>
<p>Next, in our <code>rpc-node</code>'s <code>service.rs</code> file, we extend the service with our RPC. We've chosen to install this RPC for full nodes, so we've included the code in the <code>new_full_start!</code> macro. You could also install the RPC on a light client by making the corresponding changes to <code>new_light</code>.</p>
<p>The first change to this macro is a simple type definition</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>type RpcExtension = jsonrpc_core::IoHandler&lt;sc_rpc::Metadata&gt;;
<span class="boring">}
</span></code></pre></pre>
<p>Then, once you've called the service builder, you can extend it with an RPC by using its <code>with_rpc_extensions</code> method as follows.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>.with_rpc_extensions(|client, _pool, _backend, _fetcher, _remote_blockchain| -&gt; Result&lt;RpcExtension, _&gt; {
  let mut io = jsonrpc_core::IoHandler::default();

  // Use the fully qualified name starting from `crate` because we're in macro_rules!
  io.extend_with(crate::silly_rpc::SillyRpc::to_delegate(crate::silly_rpc::Silly{}));

  Ok(io)
})
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#calling-the-rpc" id="calling-the-rpc">Calling the RPC</a></h2>
<p>Once your node is running, you can test the RPC by calling it with any client that speaks json RPC. One widely available option <code>curl</code>.</p>
<pre><code class="language-bash">$ curl http://localhost:9933 -H &quot;Content-Type:application/json;charset=utf-8&quot; -d   '{
     &quot;jsonrpc&quot;:&quot;2.0&quot;,
      &quot;id&quot;:1,
      &quot;method&quot;:&quot;silly_seven&quot;,
      &quot;params&quot;: []
    }'
</code></pre>
<p>To which the RPC responds</p>
<pre><code>{&quot;jsonrpc&quot;:&quot;2.0&quot;,&quot;result&quot;:7,&quot;id&quot;:1}
</code></pre>
<p>You may have noticed that our second RPC takes a parameter, the value to double. You can supply this parameter by including its in the  <code>params</code> list. For example:</p>
<pre><code class="language-bash">$ curl http://localhost:9933 -H &quot;Content-Type:application/json;charset=utf-8&quot; -d   '{
     &quot;jsonrpc&quot;:&quot;2.0&quot;,
      &quot;id&quot;:1,
      &quot;method&quot;:&quot;silly_double&quot;,
      &quot;params&quot;: [7]
    }'
</code></pre>
<p>To which the RPC responds with the doubled parameter</p>
<pre><code>{&quot;jsonrpc&quot;:&quot;2.0&quot;,&quot;result&quot;:14,&quot;id&quot;:1}
</code></pre>
<h2><a class="header" href="#rpc-to-call-a-runtime-api" id="rpc-to-call-a-runtime-api">RPC to Call a Runtime API</a></h2>
<p>The silly RPC demonstrates the fundamentals of working with RPCs in Substrate. Nonetheless, most RPCs will go beyond what we've learned so far, and actually interact with other parts of the node. In this second example, we will include an RPC that calls into the <code>sum-storage</code> runtime API from the <a href="3-entrees/./runtime-api.html">runtime API recipe</a>. While it isn't strictly necessary to understand what the runtime API does, reading that recipe may provide helpful context.</p>
<p>Because this RPC's behavior is closely related to a specific pallet, we've chosen to define the RPC in the pallet's directory. In this case the RPC is defined in <code>pallets/sum-storage/rpc</code>. So rather than using the <code>mod</code> keyword as we did before, we must include this RPC definition in the node's <code>Cargo.toml</code> file.</p>
<pre><code class="language-toml">sum-storage-rpc = { path = &quot;../../pallets/sum-storage/rpc&quot; }
</code></pre>
<p>Defining the RPC interface is similar to before, but there are a few differences worth noting. First, the struct that implements the RPC needs a reference to the <code>client</code>. This is necessary so we can actually call into the runtime. Second the struct is generic over the <code>BlockHash</code> type. This is because it will call a runtime API, and runtime APIs must always be called at a specific block.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>#[rpc]
pub trait SumStorageApi&lt;BlockHash&gt; {
	#[rpc(name = &quot;sumStorage_getSum&quot;)]
	fn get_sum(
		&amp;self,
		at: Option&lt;BlockHash&gt;
	) -&gt; Result&lt;u32&gt;;
}

/// A struct that implements the `SumStorageApi`.
pub struct SumStorage&lt;C, M&gt; {
	client: Arc&lt;C&gt;,
	_marker: std::marker::PhantomData&lt;M&gt;,
}

impl&lt;C, M&gt; SumStorage&lt;C, M&gt; {
	/// Create new `SumStorage` instance with the given reference to the client.
	pub fn new(client: Arc&lt;C&gt;) -&gt; Self {
		Self { client, _marker: Default::default() }
	}
}
<span class="boring">}
</span></code></pre></pre>
<p>The RPC's implementation is also similar to before. The additional syntax here is related to calling the runtime at a specific block, as well as ensuring that the runtime we're calling actually has the correct runtime API available.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>impl&lt;C, Block&gt; SumStorageApi&lt;&lt;Block as BlockT&gt;::Hash&gt;
	for SumStorage&lt;C, Block&gt;
where
	Block: BlockT,
	C: Send + Sync + 'static,
	C: ProvideRuntimeApi,
	C: HeaderBackend&lt;Block&gt;,
	C::Api: SumStorageRuntimeApi&lt;Block&gt;,
{
	fn get_sum(
		&amp;self,
		at: Option&lt;&lt;Block as BlockT&gt;::Hash&gt;
	) -&gt; Result&lt;u32&gt; {

		let api = self.client.runtime_api();
		let at = BlockId::hash(at.unwrap_or_else(||
			// If the block hash is not supplied assume the best block.
			self.client.info().best_hash
		));

		let runtime_api_result = api.get_sum(&amp;at);
		runtime_api_result.map_err(|e| RpcError {
			code: ErrorCode::ServerError(9876), // No real reason for this value
			message: &quot;Something wrong&quot;.into(),
			data: Some(format!(&quot;{:?}&quot;, e).into()),
		})
	}
}
<span class="boring">}
</span></code></pre></pre>
<p>Finally, to install this RPC on in our service, we expand the existing <code>with_rpc_extensions</code> call to</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>.with_rpc_extensions(|client, _pool, _backend, _fetcher, _remote_blockchain| -&gt; Result&lt;RpcExtension, _&gt; {
  let mut io = jsonrpc_core::IoHandler::default();

  // Use the fully qualified name starting from `crate` because we're in macro_rules!
  io.extend_with(crate::silly_rpc::SillyRpc::to_delegate(crate::silly_rpc::Silly{}));

  io.extend_with(sum_storage_rpc::SumStorageApi::to_delegate(sum_storage_rpc::SumStorage::new(client)));

  Ok(io)
})?
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#optional-rpc-parameters" id="optional-rpc-parameters">Optional RPC Parameters</a></h2>
<p>This RPC takes a parameter ,<code>at</code>, whose type is <code>Option&lt;_&gt;</code>. We may call this RPC by omitting the optional parameter entirely. In this case the implementation provides a default value of the best block.</p>
<pre><code class="language-bash">$ curl http://localhost:9933 -H &quot;Content-Type:application/json;charset=utf-8&quot; -d   '{
     &quot;jsonrpc&quot;:&quot;2.0&quot;,
      &quot;id&quot;:1,
      &quot;method&quot;:&quot;sumStorage_getSum&quot;,
      &quot;params&quot;: []
    }'
</code></pre>
<p>We may also call the RPC by providing a block hash. One easy way to get a block hash to test this call is by copying it from the logs of a running node.</p>
<pre><code class="language-bash">$ curl http://localhost:9933 -H &quot;Content-Type:application/json;charset=utf-8&quot; -d   '{
     &quot;jsonrpc&quot;:&quot;2.0&quot;,
      &quot;id&quot;:1,
      &quot;method&quot;:&quot;sumStorage_getSum&quot;,
      &quot;params&quot;: [&quot;0x87b2e4b93e74d2f06a0bde8de78c9e2a9823ce559eb5e3c4710de40a1c1071ac&quot;]
    }'
</code></pre>
<p>As an exercise, you should change the storage values, and confirm that the RPC provides the correct updated sum. Then call the RPC at an old block and confirm you get the old sum.</p>
<h2><a class="header" href="#polkadot-js-api" id="polkadot-js-api">Polkadot JS API</a></h2>
<p>Many frontends interact with Substrate nodes through Polkadot JS API. While the recipes does not strive to document that project, we have included a snippet of javascript for interacting with these custom RPCs in the <code>nodes/rpc-node/js</code> directory.</p>
<h1><a class="header" href="#currency-types" id="currency-types">Currency Types</a></h1>
<p><em><a href="https://github.com/substrate-developer-hub/recipes/tree/master/pallets/lockable-currency"><code>pallets/lockable-currency</code></a>, <a href="https://github.com/substrate-developer-hub/recipes/tree/master/pallets/reservable-currency"><code>pallets/reservable-currency</code></a>, <a href="https://github.com/substrate-developer-hub/recipes/tree/master/pallets/currency-imbalances"><code>pallets/currency-imbalances</code></a></em></p>
<h2><a class="header" href="#just-plain-currency" id="just-plain-currency">Just Plain Currency</a></h2>
<p>To use a balances type in the runtime, import the <a href="https://substrate.dev/rustdocs/master/frame_support/traits/trait.Currency.html"><code>Currency</code></a> trait from <code>frame_support</code>.</p>
<pre><code class="language-rust ignore">use support::traits::Currency;
</code></pre>
<p>The <code>Currency</code> trait provides an abstraction over a fungible assets system. To use such a fuingible asset from your pallet, include an associated type with the <code>Currency</code> trait bound in your pallet's configuration trait.</p>
<pre><code class="language-rust ignore">pub trait Trait: system::Trait {
    type Currency: Currency&lt;Self::AccountId&gt;;
}
</code></pre>
<p>Defining an associated type with this trait bound allows this pallet to access the provided methods of <a href="https://substrate.dev/rustdocs/master/frame_support/traits/trait.Currency.html"><code>Currency</code></a>. For example, it is straightforward to check the total issuance of the system:</p>
<pre><code class="language-rust ignore">// in decl_module block
T::Currency::total_issuance();
</code></pre>
<p>As promised, it is also possible to type alias a balances type for use in the runtime:</p>
<pre><code class="language-rust ignore">type BalanceOf&lt;T&gt; = &lt;&lt;T as Trait&gt;::Currency as Currency&lt;&lt;T as system::Trait&gt;::AccountId&gt;&gt;::Balance;
</code></pre>
<p>This new <code>BalanceOf&lt;T&gt;</code> type satisfies the type constraints of <code>Self::Balance</code> for the provided methods of <code>Currency</code>. This means that this type can be used for <a href="https://substrate.dev/rustdocs/master/frame_support/traits/trait.Currency.html#tymethod.transfer">transfer</a>, <a href="https://substrate.dev/rustdocs/master/frame_support/traits/trait.Currency.html#tymethod.deposit_into_existing">minting</a>, and much more.</p>
<h2><a class="header" href="#reservable-currency" id="reservable-currency">Reservable Currency</a></h2>
<p>Substrate's <a href="https://substrate.dev/rustdocs/master/pallet_treasury/index.html">Treasury pallet</a> uses the <code>Currency</code> type for bonding spending proposals. To reserve and unreserve balances for bonding, <code>treasury</code> uses the <a href="https://substrate.dev/rustdocs/master/frame_support/traits/trait.ReservableCurrency.html"><code>ReservableCurrency</code></a> trait. The import and associated type declaration follow convention</p>
<pre><code class="language-rust ignore">use frame_support::traits::{Currency, ReservableCurrency};

pub trait Trait: system::Trait {
    type Currency: Currency&lt;Self::AccountId&gt; + ReservableCurrency&lt;Self::AccountId&gt;;
}
</code></pre>
<p>To lock or unlock some quantity of funds, it is sufficient to invoke <code>reserve</code> and <code>unreserve</code> respectively</p>
<pre><code class="language-rust ignore">pub fn lock_funds(origin, amount: BalanceOf&lt;T&gt;) -&gt; Result {
    let locker = ensure_signed(origin)?;

    T::Currency::reserve(&amp;locker, amount)
            .map_err(|_| &quot;locker can't afford to lock the amount requested&quot;)?;

    let now = &lt;system::Module&lt;T&gt;&gt;::block_number();

    Self::deposit_event(RawEvent::LockFunds(locker, amount, now));
    Ok(())
}

pub fn unlock_funds(origin, amount: BalanceOf&lt;T&gt;) -&gt; Result {
    let unlocker = ensure_signed(origin)?;

    T::Currency::unreserve(&amp;unlocker, amount);

    let now = &lt;system::Module&lt;T&gt;&gt;::block_number();

    Self::deposit_event(RawEvent::LockFunds(unlocker, amount, now));
    Ok(())
}
</code></pre>
<h2><a class="header" href="#lockable-currency" id="lockable-currency">Lockable Currency</a></h2>
<p>Substrate's <a href="https://substrate.dev/rustdocs/master/pallet_staking/index.html">Staking pallet</a> similarly uses <a href="https://substrate.dev/rustdocs/master/frame_support/traits/trait.LockableCurrency.html"><code>LockableCurrency</code></a> trait for more nuanced handling of capital locking based on time increments. This type can be very useful in the context of economic systems that enforce accountability by collateralizing fungible resources. Import this trait in the usual way</p>
<pre><code class="language-rust ignore">use frame_support::traits::{LockIdentifier, LockableCurrency}
</code></pre>
<p>To use <code>LockableCurrency</code>, it is necessary to define a <a href="https://substrate.dev/rustdocs/master/frame_support/traits/type.LockIdentifier.html"><code>LockIdentifier</code></a>.</p>
<pre><code class="language-rust ignore">const EXAMPLE_ID: LockIdentifier = *b&quot;example &quot;;
</code></pre>
<p>By using this <code>EXAMPLE_ID</code>, it is straightforward to define logic within the runtime to schedule locking, unlocking, and extending existing locks.</p>
<pre><code class="language-rust ignore">fn lock_capital(origin, amount: BalanceOf&lt;T&gt;) -&gt; Result {
    let user = ensure_signed(origin)?;

    T::Currency::set_lock(
        EXAMPLE_ID,
        user.clone(),
        amount,
        WithdrawReasons::except(WithdrawReason::TransactionPayment),
    );

    Self::deposit_event(RawEvent::Locked(user, amount));
    Ok(())
}
</code></pre>
<h2><a class="header" href="#imbalances-1" id="imbalances-1">Imbalances</a></h2>
<p>Functions that alter balances return an object of the <a href="https://substrate.dev/rustdocs/master/frame_support/traits/trait.Imbalance.html"><code>Imbalance</code></a> type to express how much account balances have been altered in aggregate. This is useful in the context of state transitions that adjust the total supply of the <code>Currency</code> type in question.</p>
<p>To manage this supply adjustment, the <a href="https://substrate.dev/rustdocs/master/frame_support/traits/trait.OnUnbalanced.html"><code>OnUnbalanced</code></a> handler is often used. An example might look something like</p>
<pre><code class="language-rust ignore">// runtime method (ie decl_module block)
pub fn reward_funds(origin, to_reward: T::AccountId, reward: BalanceOf&lt;T&gt;) {
    let _ = ensure_signed(origin)?;

    let mut total_imbalance = &lt;PositiveImbalanceOf&lt;T&gt;&gt;::zero();

    let r = T::Currency::deposit_into_existing(&amp;to_reward, reward).ok();
    total_imbalance.maybe_subsume(r);
    T::Reward::on_unbalanced(total_imbalance);

    let now = &lt;system::Module&lt;T&gt;&gt;::block_number();
    Self::deposit_event(RawEvent::RewardFunds(to_reward, reward, now));
}
</code></pre>
<h2><a class="header" href="#takeaway" id="takeaway">takeaway</a></h2>
<p>The way we represent value in the runtime dictates both the security and flexibility of the underlying transactional system. Likewise, it is convenient to be able to take advantage of Rust's <a href="https://blog.rust-lang.org/2015/05/11/traits.html">flexible trait system</a> when building systems intended to rethink how we exchange information and value 🚀</p>
<h1><a class="header" href="#generating-randomness" id="generating-randomness">Generating Randomness</a></h1>
<p><em><a href="https://github.com/substrate-developer-hub/recipes/blob/master/pallets/gen-random/">pallets/gen-random</a></em></p>
<p>Substrate uses a safe mixing algorithm to generate randomness using the entropy of previous blocks. Because it is dependent on previous blocks, it can take many blocks for the seed to change.</p>
<pre><code class="language-rust ignore">let random_seed = &lt;system::Module&lt;T&gt;&gt;::random_seed();
</code></pre>
<p><strong>To increase entropy</strong>, we can introduce a nonce and a user-specified property. This provides us with a basic RNG on Substrate:</p>
<pre><code class="language-rust ignore">let random_seed = &lt;system::Module&lt;T&gt;&gt;::random_seed();
let nonce = &lt;Nonce&gt;::get();
let new_random = (random_seed, nonce)
    .using_encoded(|b| Blake2Hasher::hash(b))
    .using_encoded(|mut b| u64::decode(&amp;mut b))
    .expect(&quot;Hash must be bigger than 8 bytes; Qed&quot;);
let new_nonce = &lt;Nonce&gt;::get() + 1;
&lt;Nonce&lt;T&gt;&gt;::put(new_nonce);
</code></pre>
<p><strong>also see...</strong></p>
<ul>
<li>https://github.com/paritytech/ink/issues/57</li>
</ul>
<p><strong><a href="https://substrate.dev/recipes/">Back to Recipes</a></strong></p>
<h1><a class="header" href="#execution-schedule" id="execution-schedule">Execution Schedule</a></h1>
<p><em><a href="https://github.com/substrate-developer-hub/recipes/tree/master/pallets/execution-schedule"><code>pallets/execution-schedule</code></a></em></p>
<!-- TODO This content may need updated to match the actual pallet -->
<p>Blockchain-native mechanisms may use the block number as a proxy for time to schedule task execution. Although scheduled task execution through council governance is minimal in this example, it is not too hard to imagine tasks taking the form of subscription payments, grant payouts, or any other scheduled <em>task</em> execution.</p>
<p>This pallet demonstrates a permissioned task scheduler, in which members of a <code>council: Vec&lt;AccountId&gt;</code> can schedule tasks, which are stored in a vector in the runtime storage (<code>decl_storage</code>).</p>
<p>Members of the <code>council</code> vote on the tasks with <code>SignalQuota</code> voting power which is doled out equally to every member every <code>ExecutionFrequency</code> number of blocks.</p>
<p>Tasks with support are prioritized during execution every <code>ExecutionFrequency</code> number of blocks. More specifically, every <code>ExecutionFrequency</code> number of blocks, a maximum of <code>TaskLimit</code> number of tasks are executed. The priority of tasks is decided by the signalling of the council members.</p>
<p>The module's <code>Trait</code>:</p>
<pre><code class="language-rust ignore">// other type aliases
pub type PriorityScore = u32;

pub trait Trait: system::Trait {
    /// Overarching event type
    type Event: From&lt;Event&lt;Self&gt;&gt; + Into&lt;&lt;Self as system::Trait&gt;::Event&gt;;

    /// Quota for members to signal task priority every ExecutionFrequency
    type SignalQuota: Get&lt;PriorityScore&gt;;

    /// The frequency of batch executions for tasks (in `on_finalize`)
    type ExecutionFrequency: Get&lt;Self::BlockNumber&gt;;

    /// The maximum number of tasks that can be approved in an `ExecutionFrequency` period
    type TaskLimit: Get&lt;PriorityScore&gt;;
}
</code></pre>
<p>The task object is a struct,</p>
<pre><code class="language-rust ignore">pub type TaskId = Vec&lt;u8&gt;;
pub type PriorityScore = u32;

pub struct Task&lt;BlockNumber&gt; {
    id: TaskId,
    score: PriorityScore,
    proposed_at: BlockNumber,
}
</code></pre>
<p>The runtime method for proposing a task emits an event with the expected execution time. The calculation of the expected execution time was first naively to basically iterate the block number from the current block number until it was divisible by <code>T::ExecutionFrequency::get()</code>. While this is correct, it is clearly not the most efficient way to find the next block in which tasks are executed.</p>
<blockquote>
<p>A more complex engine for predicting task execution time may run off-chain instead of in a runtime method.</p>
</blockquote>
<p>Before adding a runtime method to estimate the <code>execution_time</code>, implement a naive implementation that iterates the global <code>BlockNumber</code> until it is divisible by <code>ExecutionFrequency</code> (which implies execution in <code>on_finalize</code> in this block).</p>
<pre><code class="language-rust ignore">fn naive_execution_estimate(now: T::BlockNumber) -&gt; T::BlockNumber {
    // the frequency with which tasks are batch executed
    let batch_frequency = T::ExecutionFrequency::get();
    let mut expected_execution_time = now;
    loop {
        // the expected execution time is the next block number divisible by `ExecutionFrequency`
        if (expected_execution_time % batch_frequency).is_zero() {
            break;
        } else {
            expected_execution_time += 1.into();
        }
    }
    expected_execution_time
}
</code></pre>
<p>This naive implementation unsurprisingly worked...</p>
<pre><code class="language-rust ignore">#[test]
fn naive_estimator_works() {
    // should use quickcheck to cover entire range of checks
    ExtBuilder::default()
        .execution_frequency(8)
        .build()
        .execute_with(|| {
            let current_block = 5u64;
            assert_eq!(
                ExecutionSchedule::naive_execution_estimate(current_block.into()),
                8u64.into()
            );
            let next_block = 67u64;
            assert_eq!(
                ExecutionSchedule::naive_execution_estimate(next_block.into()),
                72u64.into()
            );
        })
}
</code></pre>
<p>...but it is obvious that there is a better way. If execution is scheduled every constant <code>ExecutionFrequency</code> number of blocks, then it should be straightforward to calculate the next execution block without this slow iterate and check modulus method. My first attempt at a better implementation of <code>execution_estimate(n: T::BlockNumber) -&gt; T::BlockNumber</code> was</p>
<pre><code class="language-rust ignore">fn execution_estimate(n: T::BlockNumber) -&gt; T::BlockNumber {
        let batch_frequency = T::ExecutionFrequency::get();
        let miss = n % batch_frequency;
        (n + miss) - batch_frequency
    }
</code></pre>
<p>The above code failed the <code>estimator_works</code> unit test</p>
<pre><code class="language-rust ignore">#[test]
fn estimator_works() {
    ExtBuilder::default()
        .execution_frequency(8)
        .build()
        .execute_with(|| {
            assert_eq!(
                ExecutionSchedule::execution_estimate(current_block.into()),
                8u64.into()
            );
            assert_eq!(
                ExecutionSchedule::execution_estimate(next_block.into()),
                72u64.into()
            );
        })
}
</code></pre>
<p>The error helped me catch the logic mistake and change it to</p>
<pre><code class="language-rust ignore">fn execution_estimate(n: T::BlockNumber) -&gt; T::BlockNumber {
    let batch_frequency = T::ExecutionFrequency::get();
    let miss = n % batch_frequency;
    n + (batch_frequency - miss)
}
</code></pre>
<p>This makes more sense. Current block number <code>% T::ExecutionFrequency::get()</code> is, by definition of modulus, the number of blocks that the current block is past when tasks were last executed. To return the next block at which task execution is scheduled, the estimator adds the difference between <code>T::ExecutionFrequency::get()</code> and the modulus. This makes sense AND passes the <code>estimators_work()</code> test.</p>
<h2><a class="header" href="#on_initialize-updates-vote-data-and-round-information" id="on_initialize-updates-vote-data-and-round-information">on_initialize updates vote data and round information</a></h2>
<p>Each period of task proposals and voting is considered a round, expressed as <code>RoundIndex: u32</code> such that the global round is stored in the runtime storage as <code>Era</code>.</p>
<pre><code class="language-rust ignore">pub type RoundIndex = u32;

decl_storage! {
    trait Store for Module&lt;T: Trait&gt; as ExecutionSchedule {
        Era get(fn era): RoundIndex;
    }
}
</code></pre>
<p>This storage value acts as a global counter of the round, which is also used as the <code>prefix_key</code> of a <code>double_map</code> that tracks the member's remaining voting power in the <code>SignalBank</code> runtime storage item. This map and the round counter are updated in the <code>on_initialize</code> hook.</p>
<pre><code class="language-rust ignore">// in on_initialize
let last_era = &lt;Era&gt;::get();
&lt;SignalBank&lt;T&gt;&gt;::remove_prefix(&amp;last_era);
let next_era: RoundIndex = last_era + (1u32 as RoundIndex);
&lt;Era&gt;::put(next_era);
// see next code back
</code></pre>
<p>The <code>SignalBank</code> tracks the signalling power of each member of the <code>council</code>. By using a <code>double-map</code> with the prefix as the round number, it is straightforward to perform batch removal of state related to signalling in the previous round.</p>
<pre><code class="language-rust ignore">&lt;SignalBank&lt;T&gt;&gt;::remove_prefix(&amp;last_era);
</code></pre>
<p>In practice, this organization of logic uses something like a ring buffer; the <code>on_initialize</code> both batch deletes all signalling records from the previous round while, in the same code block, doling out an equal amount of voting power to all members for the next round.</p>
<pre><code class="language-rust ignore">// ...continuation of last code block
let signal_quota = T::SignalQuota::get();
&lt;Council&lt;T&gt;&gt;::get().into_iter().for_each(|member| {
    &lt;SignalBank&lt;T&gt;&gt;::insert(next_era, &amp;member, signal_quota);
});
</code></pre>
<p>The aforementioned ring buffer is maintained in the <code>on_initialize</code> block. The maintenance code is kept in an if statement that limits its invocation to blocks <code>x</code> that follow blocks <code>y</code> for which <code>y % ExecutionFrequency == 0</code>.</p>
<p>This is a common way of only exercising expensive batch execution functions every periodic number of blocks. Still, the second to last statement is confusing. The first time I encountered the problem, I placed the following in the <code>on_initialize</code> if statement that controls the maintenance of the <code>SignalBank</code> and <code>Era</code> storage values,</p>
<pre><code class="language-rust ignore">// in on_initialize(n: T::BlockNumber)
if (n % (T::ExecutionFrequency + 1.into())).is_zero() {
    //changing and repopulating of `Era` and `SignalBank`
}
</code></pre>
<p>I only noticed this mistake while testing whether eras progress as expected. Specifically, the following test failed</p>
<pre><code class="language-rust ignore">#[test]
    fn eras_change_correctly() {
    ExtBuilder::default()
        .execution_frequency(2)
        .build()
        .execute_with(|| {
            System::set_block_number(1);
            run_to_block(13);
            assert_eq!(ExecutionSchedule::era(), 6);
            run_to_block(32);
            assert_eq!(ExecutionSchedule::era(), 16);
        })
}
</code></pre>
<p>The test failed with an error message claiming that the first <code>assert_eq!</code> left side was 4 which does not equal 6. This error message caused me to inspect the if condition, which I realized should be changed to (the current implementation),</p>
<pre><code class="language-rust ignore">// in on_initialize(n: T::BlockNumber)
if ((n - 1.into()) % T::ExecutionFrequency).is_zero() {
    //changing and repopulating of `Era` and `SignalBank`
}
</code></pre>
<p>With this change, the <code>eras_change_correctly</code> test passes.</p>
<h2><a class="header" href="#on_finalize-execution-priority-a-name--prioritya" id="on_finalize-execution-priority-a-name--prioritya">on_finalize execution priority <a name = "priority"></a></a></h2>
<ul>
<li>
<p>this pattern of sorting the tasks in <code>on_finalize</code> is inspired by the <code>scored-pool</code> pallet which should be referenced</p>
</li>
<li>
<p>when we schedule and reprioritize elements in this way, order of execution becomes extremely important</p>
</li>
<li>
<p>we execute tasks in <code>on_finalize</code> when <code>n % T::ExecutionFrequency == 0</code>. I should ensure that n != 0 as well, but I assume this is the case. The limit is maximum <code>TaskLimit</code>.</p>
</li>
<li>
<p>An improvement would be to also ensure that their is some minimum amount of <code>score</code>. It would be nice to write abstractions that have a more native sense of the collective voting power of all members</p>
</li>
<li>
<p>this lends itself to a follow up off-chain workers example for how it fits between <code>on_finalize</code> of the last block and <code>on_initialize</code> of the next block <code>=&gt;</code> there is this whole <code>execution-schedule</code> :p</p>
</li>
</ul>
<h2><a class="header" href="#permissioned-methods" id="permissioned-methods">Permissioned Methods</a></h2>
<p><em><a href="https://github.com/substrate-developer-hub/recipes/tree/master/pallets/check-membership">pallets/check-membership</a></em></p>
<p>It is often useful to designate some functions as permissioned and, therefore, accessible only to a defined group. In this case, we check that the transaction that invokes the runtime function is signed before verifying that the signature corresponds to a member of the permissioned set.</p>
<p>To manage the set of members allowed to access the methods in question, we may store a vector in runtime storage. Without access to the standard library, it is necessary to use the <a href="https://substrate.dev/rustdocs/master/sp_std/vec/struct.Vec.html"><code>Vec</code> struct</a> from the <code>sp-std</code> crate.</p>
<pre><code class="language-rust ignore">use sp_std::vec::Vec;
</code></pre>
<p>In the runtime, the membership set can be stored as</p>
<pre><code class="language-rust ignore">decl_storage! {
	trait Store for Module&lt;T: Trait&gt; as PGeneric {
		Members get(fn members): Vec&lt;&amp;T::AccountId&gt;;
	}
}
</code></pre>
<h2><a class="header" href="#permissionless-membership" id="permissionless-membership">Permissionless Membership</a></h2>
<p>If the membership is permissionless such anyone can join, an <code>add_member</code> function could be expressed as follows</p>
<pre><code class="language-rust ignore">fn add_member(origin) -&gt; DispatchResult {
	let new_member = ensure_signed(origin)?;

	// Ensure that the caller is not already a member
	ensure!(!Self::is_member(&amp;new_member), &quot;already a member&quot;);

	&lt;Members&lt;T&gt;&gt;::append(&amp;[new_member.clone()])?;
	Self::deposit_event(RawEvent::AddMember(new_member));
	Ok(())
}
</code></pre>
<p>Here we've used the <a href="https://substrate.dev/rustdocs/master/frame_support/storage/trait.StorageValue.html#tymethod.append"><code>append</code> method</a> to add the new member to the list. This allows a quick way to add data to the end of the vector without decoding the entire vector.</p>
<p>To increase the readability of the code, the membership check is extracted into its own auxiliary runtime method.</p>
<pre><code class="language-rust ignore">impl&lt;T: Trait&gt; Module&lt;T&gt; {
	pub fn is_member(who: &amp;T::AccountId) -&gt; bool {
		Self::members().contains(who)
	}
}
</code></pre>
<h1><a class="header" href="#testing" id="testing">Testing</a></h1>
<p>Although the Rust compiler ensures safe memory management, it cannot formally verify the correctness of a program's logic. Fortunately, Rust also comes with great libraries and documentation for writing unit and integration tests. When you initiate code with Cargo, test scaffolding is automatically generated to simplify the developer experience. Basic testing concepts and syntax are covered in depth in <a href="https://doc.rust-lang.org/book/ch11-00-testing.html">Chapter 11 of the Rust Book</a>.</p>
<ul>
<li><a href="3-entrees/testing/./mock.html">Basic Test Environments</a></li>
<li><a href="3-entrees/testing/./common.html">Common Tests</a></li>
<li><a href="3-entrees/testing/./externalities.html">Custom Test Environment</a></li>
</ul>
<p>There's also more rigorous testing systems ranging from mocking and fuzzing to formal verification. See <a href="https://docs.rs/quickcheck/0.9.0/quickcheck/">quickcheck</a> for an example of a property-based testing framework ported from Haskell to Rust.</p>
<h2><a class="header" href="#kitchen-pallets-with-unit-tests" id="kitchen-pallets-with-unit-tests">Kitchen Pallets with Unit Tests</a></h2>
<p>The following modules in the kitchen have partial unit test coverage</p>
<ul>
<li><a href="https://github.com/substrate-developer-hub/recipes/tree/master/pallets/struct-storage"><code>struct-storage</code></a></li>
<li><a href="https://github.com/substrate-developer-hub/recipes/tree/master/pallets/adding-machine"><code>adding-machine</code></a></li>
<li><a href="https://github.com/substrate-developer-hub/recipes/tree/master/pallets/simple-event"><code>simple-event</code></a></li>
<li><a href="https://github.com/substrate-developer-hub/recipes/tree/master/pallets/generic-event"><code>generic-event</code></a></li>
<li><a href="https://github.com/substrate-developer-hub/recipes/tree/master/pallets/single-value"><code>single-value</code></a></li>
<li><a href="https://github.com/substrate-developer-hub/recipes/tree/master/pallets/simple-map"><code>simple-map</code></a></li>
<li><a href="https://github.com/substrate-developer-hub/recipes/tree/master/pallets/double-map"><code>double-map</code></a></li>
<li><a href="https://github.com/substrate-developer-hub/recipes/tree/master/pallets/storage-cache"><code>storage-cache</code></a></li>
<li><a href="https://github.com/substrate-developer-hub/recipes/tree/master/pallets/vec-set"><code>vec-set</code></a></li>
<li><a href="https://github.com/substrate-developer-hub/recipes/tree/master/pallets/constant-config"><code>constant-config</code></a></li>
</ul>
<h3><a class="header" href="#cooking-in-the-kitchen-running-tests" id="cooking-in-the-kitchen-running-tests">Cooking in the Kitchen (Running Tests)</a></h3>
<p>To run the tests, clone the repo</p>
<pre><code class="language-bash">$ git clone https://github.com/substrate-developer-hub/recipes
</code></pre>
<p>Enter the path to the pallet to be tested</p>
<pre><code class="language-bash">$ cd pallets/&lt;some-module&gt;
</code></pre>
<p>For example, to test <code>constant-config</code>, used in <a href="https://substrate.dev/recipes/3-entrees/constants.html">Configurable Constants</a>,</p>
<pre><code class="language-bash">$ cd pallets/constant-config/
$ cargo test
</code></pre>
<p>Writing unit tests is one of the best ways to understand the code. Although unit tests are not comprehensive, they provide a first check to verify that the programmer's basic invariants are not violated in the presence of obvious, expected state changes.</p>
<h1><a class="header" href="#mock-runtime-for-unit-testing" id="mock-runtime-for-unit-testing">Mock Runtime for Unit Testing</a></h1>
<p><em>See <a href="3-entrees/testing/./index.html">Testing</a> page for list of kitchen pallets with unit test coverage.</em></p>
<p>There are two main patterns on writing tests for pallets. We can put the tests:</p>
<ol>
<li>
<p>At the bottom of the pallet, place unit tests in a separate Rust module with a special compilation flag</p>
<pre><code class="language-rust ignore">#[cfg(test)]
mod tests {
	// -- snip --
}
</code></pre>
</li>
<li>
<p>In a separate file called <code>tests.rs</code> inside <code>src</code> folder, and conditionally include tests inside the main <code>lib.rs</code>. At the top of the <code>lib.rs</code></p>
<pre><code class="language-rust ignore">#[cfg(test)]
mod tests;
</code></pre>
</li>
</ol>
<p>Now, to use the logic from the pallet under test, bring <code>Module</code> and <code>Trait</code> into scope.</p>
<pre><code class="language-rust ignore">use crate::{Module, Trait};
</code></pre>
<h2><a class="header" href="#create-the-outer-environment-for-mock-runtime" id="create-the-outer-environment-for-mock-runtime">Create the Outer Environment for Mock Runtime</a></h2>
<p>Before we create the mock runtime that take our pallet to run tests, we first need to create the
outer environment for the runtime as follows:</p>
<pre><code class="language-rust ignore">use support::{impl_outer_event, impl_outer_origin, parameter_types};
use runtime_primitives::{Perbill, traits::{IdentityLookup, BlakeTwo256}, testing::Header};
use runtime_io;
use primitives::{H256};

// We define the outer `Origin` enum and `Event` enum.
// You may not be aware that these enums are created when writing the runtime/pallet;
//   it is because they are created through the `construct_runtime!` macro.
// Also, these are not standard Rust but the syntax expected when parsed inside
//   these macros.
impl_outer_origin! {
	pub enum Origin for TestRuntime {}
}

// -- If you want to test events, add the following. Otherwise, please ignore --
mod test_events {
	pub use crate::Event;
}

impl_outer_event! {
	pub enum TestEvent for TestRuntime {
		test_events,
		system&lt;T&gt;,
	}
}
// -- End: Code setup for testing events --
</code></pre>
<h2><a class="header" href="#define-mock-runtime-and-implement-necessary-pallet-traits" id="define-mock-runtime-and-implement-necessary-pallet-traits">Define Mock Runtime and Implement Necessary Pallet Traits</a></h2>
<p>Now, declare the mock runtime as a unit structure</p>
<pre><code class="language-rust ignore">#[derive(Clone, PartialEq, Eq, Debug)]
pub struct TestRuntime;
</code></pre>
<p>The <code>derive</code> macro attribute provides implementations of the <code>Clone + PartialEq + Eq + Debug</code> traits for the <code>TestRuntime</code> struct.</p>
<p>The mock runtime also needs to implement the tested pallet's <code>Trait</code>. If it is unnecessary to test the pallet's <code>Event</code> type, the type can be set to <code>()</code>. See further below to test the pallet's <code>Event</code> enum.</p>
<pre><code class="language-rust ignore">impl Trait for TestRuntime {
	type Event = ();
}
</code></pre>
<p>Next, we create a new type that wraps the mock <code>TestRuntime</code> in the pallet's <code>Module</code>.</p>
<pre><code class="language-rust ignore">pub type TestPallet = Module&lt;TestRuntime&gt;;
</code></pre>
<p>It may be helpful to read this as type aliasing our configured mock runtime to work with the pallet's <code>Module</code>, which is what is ultimately being tested.</p>
<p>In many cases, the pallet's <code>Trait</code> is further bound by <code>system::Trait</code> like:</p>
<pre><code class="language-rust ignore">pub trait Trait: system::Trait {
	type Event: From&lt;Event&lt;Self&gt;&gt; + Into&lt;&lt;Self as system::Trait&gt;::Event&gt;;
}
</code></pre>
<p>The mock runtime must inherit and define the <code>system::Trait</code> associated types. To do so, <code>impl</code> the <code>system::Trait</code>
for <code>TestRuntime</code> with types created previously and imported from other crates.</p>
<pre><code class="language-rust ignore">#[derive(Clone, PartialEq, Eq, Debug)]
pub struct TestRuntime;

parameter_types! {
	pub const BlockHashCount: u64 = 250;
	pub const MaximumBlockWeight: u32 = 1024;
	pub const MaximumBlockLength: u32 = 2 * 1024;
	pub const AvailableBlockRatio: Perbill = Perbill::one();
}

// First, implement the system pallet's configuration trait for `TestRuntime`
impl system::Trait for TestRuntime {
	type Origin = Origin;
	type Index = u64;
	type Call = ();
	type BlockNumber = u64;
	type Hash = H256;
	type Hashing = BlakeTwo256;
	type AccountId = u64;
	type Lookup = IdentityLookup&lt;Self::AccountId&gt;;
	type Header = Header;
	// To test events, use `TestEvent`. Otherwise, use the commented line
	type Event = TestEvent;
	// type Event = ();
	type BlockHashCount = BlockHashCount;
	type MaximumBlockWeight = MaximumBlockWeight;
	type MaximumBlockLength = MaximumBlockLength;
	type AvailableBlockRatio = AvailableBlockRatio;
	type Version = ();
	type ModuleToIndex = ();
	type AccountData = ();
	type OnNewAccount = ();
	type OnKilledAccount = ();
}

// Then implement our own pallet's configuration trait for `TestRuntime`
impl Trait for TestRuntime {
	type Event = TestEvent;
}

// Assign back to type variables so we can make dispatched calls of these modules later.
pub type System = system::Module&lt;TestRuntime&gt;;
pub type TestPallet = Module&lt;TestRuntime&gt;;
</code></pre>
<p>With this, it is possible to use this type in the unit tests. For example, the block number can be set with <a href="https://substrate.dev/rustdocs/master/frame_system/struct.Module.html#method.set_block_number"><code>set_block_number</code></a></p>
<pre><code class="language-rust ignore">#[test]
fn add_emits_correct_event() {
	// ExtBuilder syntax is explained further below
	ExtBuilder::build().execute_with(|| {
		System::set_block_number(2);
		// some assert statements and HelloSubstrate calls
	}
}
</code></pre>
<h2><a class="header" href="#basic-test-environments" id="basic-test-environments">Basic Test Environments</a></h2>
<p>To build the test runtime environment, import <code>runtime_io</code></p>
<pre><code class="language-rust ignore">use runtime_io;
</code></pre>
<p>In the <code>Cargo.toml</code>, this only needs to be imported under <code>dev-dependencies</code> since it is only used in the <code>tests</code> module. It also doesn't need to be feature gated in the <code>std</code> feature.</p>
<pre><code>[dev-dependencies.sp-io]
default_features = false
git = 'https://github.com/paritytech/substrate.git'
tag = 'v2.0.0-alpha.3'
</code></pre>
<p>There is more than one pattern for building a mock runtime environment for testing pallet logic. Two patterns are presented below. The latter is generally favored for reasons discussed in <a href="3-entrees/testing/./externalities.html">custom test environment</a></p>
<ul>
<li><a href="3-entrees/testing/mock.html#newext"><code>new_test_ext</code></a> -  consolidates all the logic for building the environment to a single public method, but isn't relatively configurable (i.e. uses one set of pallet constants)</li>
<li><a href="3-entrees/testing/mock.html#extbuilder"><code>ExtBuilder</code></a> - define methods on the unit struct <code>ExtBuilder</code> to facilitate a flexible environment for tests (i.e. can reconfigure pallet constants in every test if necessary)</li>
</ul>
<h2><a class="header" href="#new_test_ext-a-name--newexta" id="new_test_ext-a-name--newexta">new_test_ext <a name = "newext"><a/></a></h2>
<p><em><a href="https://github.com/substrate-developer-hub/recipes/tree/master/pallets/charity"><code>pallets/smpl-treasury</code></a></em></p>
<p>In <a href="https://github.com/substrate-developer-hub/recipes/tree/master/pallets/charity"><code>smpl-treasury</code></a>, use the <code>balances::GenesisConfig</code> and the pallet's <code>Genesis::&lt;TestRuntime&gt;</code> to set the balances of the test accounts and establish council membership in the returned test environment.</p>
<pre><code class="language-rust ignore">pub fn new_test_ext() -&gt; runtime_io::TestExternalities {
	let mut t = system::GenesisConfig::default().build_storage::&lt;TestRuntime&gt;().unwrap();
	balances::GenesisConfig::&lt;TestRuntime&gt; {
		balances: vec![
			// members of council (can also be users)
			(1, 13),
			(2, 11),
			(3, 1),
			(4, 3),
			(5, 19),
			(6, 23),
			(7, 17),
			// users, not members of council
			(8, 1),
			(9, 22),
			(10, 46),
		],
		vesting: vec![],
	}.assimilate_storage(&amp;mut t).unwrap();
	GenesisConfig::&lt;TestRuntime&gt;{
		council: vec![
			1,
			2,
			3,
			4,
			5,
			6,
			7,
		]
	}.assimilate_storage(&amp;mut t).unwrap();
	t.into()
}
</code></pre>
<p>More specifically, this sets the <code>AccountId</code>s in the range of <code>[1, 7]</code> inclusive as the members of the <code>council</code>. This is expressed in the <code>decl_module</code> block with the addition of an <code>add_extra_genesis</code> block,</p>
<pre><code class="language-rust ignore">add_extra_genesis {
	build(|config| {
		// ..other stuff..
		&lt;Council&lt;T&gt;&gt;::put(&amp;config.council);
	});
}
</code></pre>
<p>To use <code>new_test_ext</code> in a runtime test, we call the method and call <a href="https://substrate.dev/rustdocs/master/sp_state_machine/struct.TestExternalities.html#method.execute_with"><code>execute_with</code></a> on the returned <code>runtime_io::TestExternalities</code></p>
<pre><code class="language-rust ignore">#[test]
fn fake_test() {
	new_test_ext().execute_with(|| {
		// test logic
	})
}
</code></pre>
<p><code>execute_with</code> executes all logic expressed in the closure within the configured runtime test environment specified in <code>new_test_ext</code></p>
<h2><a class="header" href="#extbuilder-a-name--extbuildera" id="extbuilder-a-name--extbuildera">ExtBuilder <a name = "extbuilder"></a></a></h2>
<p><em><a href="https://github.com/substrate-developer-hub/recipes/tree/master/pallets/struct-storage"><code>pallets/struct-storage</code></a></em></p>
<p>Another approach for a more flexible runtime test environment instantiates a unit struct <code>ExtBuilder</code>,</p>
<pre><code class="language-rust ignore">pub struct ExtBuilder;
</code></pre>
<p>The behavior for constructing the test environment is contained the methods on the <code>ExtBuilder</code> unit structure. This fosters multiple levels of configuration depending on if the test requires a common default instance of the environment or a more specific edge case configuration. The latter is explored in more detail in <a href="3-entrees/testing/./externalities.html">Custom Test Environment</a>.</p>
<p>Like <code>new_test_ext</code>, the <code>build()</code> method on the <code>ExtBuilder</code> object returns an instance of <a href="https://substrate.dev/rustdocs/master/sp_state_machine/struct.TestExternalities.html"><code>TestExternalities</code></a>. <a href="https://substrate.dev/rustdocs/master/sp_externalities/index.html">Externalities</a> are an abstraction that allows the runtime to access features of the outer node such as storage or offchain workers.</p>
<p>In this case, create a mock storage from the default genesis configuration.</p>
<pre><code class="language-rust ignore">impl ExtBuilder {
	pub fn build() -&gt; runtime_io::TestExternalities {
		let mut storage = system::GenesisConfig::default().build_storage::&lt;TestRuntime&gt;().unwrap();
		runtime_io::TestExternalities::from(storage)
	}
}
</code></pre>
<p>which calls some methods to create a test environment,</p>
<pre><code class="language-rust ignore">#[test]
fn fake_test_example() {
	ExtBuilder::build().execute_with(|| {
		// ...test conditions...
	})
}
</code></pre>
<p>While testing in this environment, runtimes that require signed extrinsics (aka take <code>origin</code> as a parameter) will require transactions coming from an <code>Origin</code>. This requires importing the <a href="https://substrate.dev/rustdocs/master/frame_support/macro.impl_outer_origin.html"><code>impl_outer_origin</code></a> macro from <code>support</code></p>
<pre><code class="language-rust ignore">use support::{impl_outer_origin};

impl_outer_origin!{
	pub enum Origin for TestRuntime {}
}
</code></pre>
<p>It is possible to placed signed transactions as parameters in runtime methods that require the <code>origin</code> input. See the <a href="https://github.com/substrate-developer-hub/recipes/tree/master/pallets/hello-substrate">full code in the kitchen</a>, but this looks like</p>
<pre><code class="language-rust ignore">#[test]
fn last_value_updates() {
	ExtBuilder::build().execute_with(|| {
		HelloSubstrate::set_value(Origin::signed(1), 10u64);
		// some assert statements
	})
}
</code></pre>
<p>Run these tests with <code>cargo test</code>, an optional parameter is the test's name to only run that test and not all tests.</p>
<p>NOTE: the input to <code>Origin::signed</code> is the <code>system::Trait</code>'s <code>AccountId</code> type which was set to <code>u64</code> for the <code>TestRuntime</code> implementation. In theory, this could be set to some other type as long as it conforms to the <a href="https://substrate.dev/rustdocs/master/frame_system/trait.Trait.html#associatedtype.AccountId">trait bound</a>,</p>
<pre><code class="language-rust ignore">pub trait Trait: 'static + Eq + Clone {
	//...
	type AccountId: Parameter + Member + MaybeSerializeDeserialize + Debug + MaybeDisplay + Ord + Default;
	//...
}
</code></pre>
<!-- add link to testing in devhub docs after it is added -->
<h1><a class="header" href="#common-tests" id="common-tests">Common Tests</a></h1>
<p>To verify that our pallet code behaves as expected, it is necessary to check a few conditions with unit tests. Intuitively, the order of the testing may resemble the structure of runtime method development.</p>
<ol>
<li>Within each runtime method, declarative checks are made prior to any state change. These checks ensure that any required conditions are met before all changes occur; need to ensure that <a href="3-entrees/testing/common.html#panicspanic">panics panic</a>.</li>
<li>Next, verify that the <a href="3-entrees/testing/common.html#storage">expected storage changes occurred</a>.</li>
<li>Finally, check that the <a href="3-entrees/testing/common.html#events">expected events were emitted</a> with correct values.</li>
</ol>
<h3><a class="header" href="#checks-before-changes-are-enforced-ie-panics-panic-a-name--panicspanica" id="checks-before-changes-are-enforced-ie-panics-panic-a-name--panicspanica">Checks before Changes are Enforced (i.e. Panics Panic) <a name = "panicspanic"></a></a></h3>
<p>The <code>Verify First, Write Last</code> paradigm encourages verifying certain conditions before changing storage values. In tests, it might be desirable to verify that invalid inputs return the expected error message.</p>
<p>In <a href="https://github.com/substrate-developer-hub/recipes/tree/master/pallets/adding-machine"><code>pallets/adding-machine</code></a>, the runtime method <code>add</code> checks for overflow</p>
<pre><code class="language-rust ignore">decl_module! {
    pub struct Module&lt;T: Trait&gt; for enum Call where origin: T::Origin {
        fn deposit_event() = default;

        fn add(origin, val1: u32, val2: u32) -&gt; Result {
            let _ = ensure_signed(origin)?;
            // checks for overflow
            let result = match val1.checked_add(val2) {
                Some(r) =&gt; r,
                None =&gt; return Err(&quot;Addition overflowed&quot;),
            };
            Self::deposit_event(Event::Added(val1, val2, result));
            Ok(())
        }
    }
}
</code></pre>
<p>The test below verifies that the expected error is thrown for a specific case of overflow.</p>
<pre><code class="language-rust ignore">#[test]
fn overflow_fails() {
	ExtBuilder::build().execute_with(|| {
		assert_err!(
			AddingMachine::add(Origin::signed(3), u32::max_value(), 1),
			&quot;Addition overflowed&quot;
		);
	})
}
</code></pre>
<p>This requires importing the <code>assert_err</code> macro from <code>support</code>. With all the previous imported objects,</p>
<pre><code class="language-rust ignore">#[cfg(test)]
mod tests {
	use support::{assert_err, impl_outer_event, impl_outer_origin, parameter_types};
	// more imports and tests
}
</code></pre>
<p>For more examples, see <a href="https://github.com/paritytech/substrate/tree/master/frame">Substrate's own pallets</a> -- <code>mock.rs</code> for mock runtime scaffolding and <code>test.rs</code> for unit tests.</p>
<h3><a class="header" href="#expected-changes-to-storage-are-triggered-a-name--storagea" id="expected-changes-to-storage-are-triggered-a-name--storagea">Expected Changes to Storage are Triggered <a name = "storage"></a></a></h3>
<p><em><a href="https://github.com/substrate-developer-hub/recipes/tree/master/pallets/single-value">pallets/single-value</a></em></p>
<p>Changes to storage can be checked by direct calls to the storage values. The syntax is the same as it would be in the pallet's runtime methods.</p>
<pre><code class="language-rust ignore">use crate::*;

#[test]
fn set_value_works() {
  ExtBuilder::build().execute_with(|| {
    assert_ok!(SingleValue::set_value(Origin::signed(1), 10));
    assert_eq!(SingleValue::stored_value(), 10);
    // Another way of accessing the storage. This pattern is needed if it is a more complexed data
    //   type, e.g. StorageMap, StorageLinkedMap
    assert_eq!(&lt;StoredValue&gt;::get(), 10);
  })
}
</code></pre>
<p>For context, the tested pallets's <code>decl_storage</code> block looks like</p>
<pre><code class="language-rust ignore">decl_storage! {
  trait Store for Module&lt;T: Trait&gt; as SingleValue {
    StoredValue get(fn stored_value): u32;
    StoredAccount get(fn stored_account): T::AccountId;
  }
}
</code></pre>
<h3><a class="header" href="#expected-events-are-emitted-a-name--eventsa" id="expected-events-are-emitted-a-name--eventsa">Expected Events are Emitted <a name = "events"></a></a></h3>
<p>The common way of testing expected event emission behavior requires importing <code>support</code>'s <a href="https://substrate.dev/rustdocs/master/frame_support/macro.impl_outer_event.html"><code>impl_outer_event!</code></a> macro</p>
<pre><code class="language-rust ignore">use support::impl_outer_event;
</code></pre>
<p>The <code>TestEvent</code> enum imports and uses the pallet's <code>Event</code> enum. The new local pallet, <code>hello_substrate</code>, re-exports the contents of the root to give a name for the current crate to <code>impl_outer_event!</code>.</p>
<pre><code class="language-rust ignore">mod hello_substrate {
	pub use crate::Event;
}

impl_outer_event! {
	pub enum TestEvent for TestRuntime {
		hello_substrate&lt;T&gt;,
	}
}

impl Trait for TestRuntime {
	type Event = TestEvent;
}
</code></pre>
<p>Testing the correct emission of events compares constructions of expected events with the entries in the <a href="https://substrate.dev/rustdocs/master/frame_system/struct.Module.html#method.events"><code>System::events</code></a> vector of <code>EventRecord</code>s. In <a href="https://github.com/substrate-developer-hub/recipes/tree/master//pallets/adding-machine"><code>pallets/adding-machine</code></a>,</p>
<pre><code class="language-rust ignore">#[test]
fn add_emits_correct_event() {
	ExtBuilder::build().execute_with(|| {
		AddingMachine::add(Origin::signed(1), 6, 9);

		assert_eq!(
			System::events(),
			vec![
				EventRecord {
					phase: Phase::ApplyExtrinsic(0),
					event: TestEvent::added(crate::Event::Added(6, 9, 15)),
					topics: vec![],
				},
			]
		);
	})
}
</code></pre>
<p>This check requires importing from <code>system</code></p>
<pre><code class="language-rust ignore">use system::{EventRecord, Phase};
</code></pre>
<p>A more ergonomic way of testing whether a specific event was emitted might use the <code>System::events().iter()</code>. This pattern doesn't require the previous imports, but it does require importing <code>RawEvent</code> (or <code>Event</code>) from the pallet and <code>ensure_signed</code> from <code>system</code> to convert signed extrinsics to the underlying <code>AccountId</code>,</p>
<pre><code class="language-rust ignore">#[cfg(test)]
mod tests {
	// other imports
	use system::ensure_signed;
	use super::RawEvent; // if no RawEvent, then `use super::Event;`
	// tests
}
</code></pre>
<p>In <a href="https://github.com/substrate-developer-hub/recipes/tree/master/pallets/hello-substrate"><code>pallets/hello-substrate</code></a>,</p>
<pre><code class="language-rust ignore">#[test]
fn last_value_updates() {
	ExtBuilder::build().execute_with(|| {
		HelloSubstrate::set_value(Origin::signed(1), 10u64);
		// some assert checks

		let id_1 = ensure_signed(Origin::signed(1)).unwrap();
		let expected_event1 = TestEvent::hello_substrate(
			RawEvent::ValueSet(id_1, 10),
		);
		assert!(System::events().iter().any(|a| a.event == expected_event1));
	})
}
</code></pre>
<p>This test constructs an <code>expected_event1</code> based on the event that the developer expects will be emitted upon the successful execution of logic in <code>HelloSubstrate::set_value</code>. The <code>assert!()</code> statement checks if the <code>expected_event1</code> matches the <code>.event</code> field for any <code>EventRecord</code> in the <code>System::events()</code> vector.</p>
<h1><a class="header" href="#custom-test-environment" id="custom-test-environment">Custom Test Environment</a></h1>
<p><a href="3-entrees/testing/../execution-schedule.html"><code>execution-schedule</code></a>'s configuration trait has three <a href="3-entrees/testing/../constants.html">configurable constants</a>. For this mock runtime, the <code>ExtBuilder</code> defines setters to enable the <code>TestExternalities</code> instance for each unit test to configure the local test runtime environment with different value assignments. For context, the <code>Trait</code> for <code>execution-schedule</code>,</p>
<pre><code class="language-rust ignore">// other type aliases
pub type PriorityScore = u32;

pub trait Trait: system::Trait {
    /// Overarching event type
    type Event: From&lt;Event&lt;Self&gt;&gt; + Into&lt;&lt;Self as system::Trait&gt;::Event&gt;;

    /// Quota for members to signal task priority every ExecutionFrequency
    type SignalQuota: Get&lt;PriorityScore&gt;;

    /// The frequency of batch executions for tasks (in `on_finalize`)
    type ExecutionFrequency: Get&lt;Self::BlockNumber&gt;;

    /// The maximum number of tasks that can be approved in an `ExecutionFrequency` period
    type TaskLimit: Get&lt;PriorityScore&gt;;
}
</code></pre>
<p>The mock runtime environment extends the <a href="3-entrees/testing/./mock.html">previously discussed</a> <code>ExtBuilder</code> pattern with fields for each configurable constant and a default implementation.</p>
<blockquote>
<p>This completes the <a href="https://youtu.be/geovSK3wMB8?t=729">builder</a> pattern by defining a default configuraton to be used in a plurality of test cases while also providing setter methods to overwrite the values for each field.</p>
</blockquote>
<pre><code class="language-rust ignore">pub struct ExtBuilder {
    signal_quota: u32,
    execution_frequency: u64,
    task_limit: u32,
}
impl Default for ExtBuilder {
    fn default() -&gt; Self {
        Self {
            signal_quota: 100u32,
            execution_frequency: 5u64,
            task_limit: 10u32,
        }
    }
}
</code></pre>
<p>The setter methods for each configurable constant are defined in the <code>ExtBuilder</code> methods. This allows each instance of <code>ExtBuilder</code> to set the constant parameters for the unit test in question.</p>
<pre><code class="language-rust ignore">impl ExtBuilder {
    pub fn signal_quota(mut self, signal_quota: u32) -&gt; Self {
        self.signal_quota = signal_quota;
        self
    }
    pub fn execution_frequency(mut self, execution_frequency: u64) -&gt; Self {
        self.execution_frequency = execution_frequency;
        self
    }
    pub fn task_limit(mut self, task_limit: u32) -&gt; Self {
        self.task_limit = task_limit;
        self
    }
    // more methods e.g. build()
}
</code></pre>
<p>To allow for separate copies of the constant objects to be used in each thread, the variables assigned as constants are declared as <a href="https://substrate.dev/rustdocs/master/thread_local/index.html"><code>thread_local!</code></a>,</p>
<pre><code class="language-rust ignore">thread_local! {
    static SIGNAL_QUOTA: RefCell&lt;u32&gt; = RefCell::new(0);
    static EXECUTION_FREQUENCY: RefCell&lt;u64&gt; = RefCell::new(0);
    static TASK_LIMIT: RefCell&lt;u32&gt; = RefCell::new(0);
}
</code></pre>
<p>Each configurable constant type also maintains unit structs with implementation of <code>Get&lt;T&gt;</code> from the type <code>T</code> assigned to the pallet constant in the mock runtime implementation.</p>
<pre><code class="language-rust ignore">pub struct SignalQuota;
impl Get&lt;u32&gt; for SignalQuota {
    fn get() -&gt; u32 {
        SIGNAL_QUOTA.with(|v| *v.borrow())
    }
}

pub struct ExecutionFrequency;
impl Get&lt;u64&gt; for ExecutionFrequency {
    fn get() -&gt; u64 {
        EXECUTION_FREQUENCY.with(|v| *v.borrow())
    }
}

pub struct TaskLimit;
impl Get&lt;u32&gt; for TaskLimit {
    fn get() -&gt; u32 {
        TASK_LIMIT.with(|v| *v.borrow())
    }
}
</code></pre>
<p>The build method on <code>ExtBuilder</code> sets the associated constants before building the default storage configuration.</p>
<pre><code class="language-rust ignore">impl ExtBuilder {
    // setters
    pub fn set_associated_consts(&amp;self) {
        SIGNAL_QUOTA.with(|v| *v.borrow_mut() = self.signal_quota);
        EXECUTION_FREQUENCY.with(|v| *v.borrow_mut() = self.execution_frequency);
        TASK_LIMIT.with(|v| *v.borrow_mut() = self.task_limit);
    }
    // build()
}
</code></pre>
<p>To build the default test environment, the syntax looks like</p>
<pre><code class="language-rust ignore">#[test]
fn fake_test() {
    ExtBuilder::default()
        .build()
        .execute_with(|| {
            // testing logic and checks
        })
}
</code></pre>
<p>To configure a test environment in which the <code>execution_frequency</code> is set to <code>2</code>, the <code>eras_change_correctly</code> test invokes the <code>execution_frequency</code> setter declared in as a method on <code>ExtBuilder</code>,</p>
<pre><code class="language-rust ignore">#[test]
fn fake_test2() {
    ExtBuilder::default()
        .execution_frequency(2)
        .build()
        .execute_with(|| {
            // testing logic and checks
        })
}
</code></pre>
<p>The test environment mocked above is actually used for the cursory and incomplete test <code>eras_change_correctly</code>. This test guided the structure of the if condition in <code>on_initialize</code> to periodically reset the <code>SignalBank</code> and increment the <code>Era</code>.</p>
<p>For more examples of the mock runtime scaffolding pattern used in <a href="https://github.com/substrate-developer-hub/recipes/tree/master/pallets/execution-schedule"><code>execution-schedule</code></a>, see <code>balances/mock.rs</code> and <code>contract/tests.rs</code>.</p>
<h1><a class="header" href="#safe-math" id="safe-math">Safe Math</a></h1>
<p>We can use the <code>checked</code> traits in <a href="https://substrate.dev/rustdocs/master/sp_runtime/traits/index.html">substrate-primitives</a> to protect against <a href="https://medium.com/@taabishm2/integer-overflow-underflow-and-floating-point-imprecision-6ba869a99033">overflow/underflow</a> when incrementing/decrementing objects in our runtime. To follow the <a href="https://shawntabrizi.com/substrate-collectables-workshop/#/2/tracking-all-kitties?id=checking-for-overflowunderflow">Substrat collectable tutorial example</a>, use <a href="https://substrate.dev/rustdocs/master/sp_runtime/traits/trait.CheckedAdd.html"><code>checked_add()</code></a> to safely handle the possibility of overflow when incremementing a global counter. <em>Note that this check is similar to <a href="https://ethereumdev.io/safemath-protect-overflows/"><code>SafeMath</code></a> in Solidity</em>. </p>
<pre><code class="language-rust ignore">use runtime_primitives::traits::CheckedAdd;

let all_people_count = Self::num_of_people();

let new_all_people_count = all_people_count.checked_add(1).ok_or(&quot;Overflow adding a new person&quot;)?;
</code></pre>
<p><a href="https://doc.rust-lang.org/std/option/enum.Option.html#method.ok_or"><code>ok_or()</code></a> transforms an <code>Option</code> from <code>Some(value)</code> to <code>Ok(value)</code> or <code>None</code> to <code>Err(error)</code>. The <a href="https://doc.rust-lang.org/nightly/edition-guide/rust-2018/error-handling-and-panics/the-question-mark-operator-for-easier-error-handling.html"><code>?</code> operator</a> facilitates error propagation. In this case, using <code>ok_or()</code> is the same as writing</p>
<pre><code class="language-rust ignore">let new_all_people_count = match all_people_count.checked_add(1) {
    Some (c) =&gt; c,
    None =&gt; return Err(&quot;Overflow adding a new person&quot;),
};
</code></pre>
<h2><a class="header" href="#todo" id="todo">todo</a></h2>
<ul>
<li><code>?</code> for error propagation</li>
<li>Permill, Perbill, Fixed64 types for large arithmetic</li>
<li><code>quantization</code> benchmarks in the <code>treasury</code> tests to verify that large arithmetic stays in a comfortable error bound</li>
<li>ADD BACK IN NEW RECIPE: <code>collide</code> and the question of whether maps prevent key collisions? could discuss <code>sort</code>, <code>sort_unstable</code>, and the ordering traits here...</li>
</ul>
<h1><a class="header" href="#more-resources" id="more-resources">More Resources</a></h1>
<h2><a class="header" href="#substrate" id="substrate">Substrate</a></h2>
<p>Learn more about Substrate from these resources:</p>
<ul>
<li><a href="https://substrate.dev">Substrate Developer Hub Home</a> - Landing page of the official Substrate documentation.</li>
<li><a href="https://substrate.dev/docs">Conceptual Docs</a> - Explanation of Substrate's architecture at a high level of abstraction.</li>
<li><a href="https://substrate.dev/rustdocs">Reference Docs</a> - Documentaiton on specific Substrate APIs with little abstraction.</li>
<li><a href="https://substrate.dev/tutorials">Substrate Tutorials</a> - Step by step guides to accomplish specific tasks with Substrate.</li>
</ul>
<!-- Reminder: There is a _lot_ more potential content for this section in drafts/dessert.md -->
<h2><a class="header" href="#rust" id="rust">Rust</a></h2>
<p>Once you've got the fundamentals of Substrate, it can only help to know more rust. Here is a collection of helpful docs
and blog posts to take you down the rabbit hole.</p>
<h3><a class="header" href="#api-design" id="api-design">API Design</a></h3>
<p>To become more familiar with commmon design patterns in Rust, the following links might be helpful:</p>
<ul>
<li><a href="https://rust-lang.github.io/api-guidelines/about.html">Official Rust API Guidelines</a></li>
<li><a href="https://github.com/rust-unofficial/patterns">Rust Unofficial Design Patterns</a></li>
<li><a href="https://deterministic.space/elegant-apis-in-rust.html">Elegant Library API Guidelines</a></li>
</ul>
<h3><a class="header" href="#optimizations" id="optimizations">Optimizations</a></h3>
<p>To optimize runtime performance, Substrate developers should make use of iterators, traits, and Rust's other &quot;<em>zero cost</em> abstractions&quot;:</p>
<ul>
<li><a href="https://blog.rust-lang.org/2015/05/11/traits.html">Abstraction without overhead: traits in Rust</a>, <a href="https://www.youtube.com/watch?v=Sn3JklPAVLk">related conference talk</a></li>
<li><a href="https://hermanradtke.com/2015/06/22/effectively-using-iterators-in-rust.html">Effectively Using Iterators in Rust</a></li>
<li><a href="http://troubles.md/posts/rust-optimization/">Achieving Warp Speed with Rust</a></li>
</ul>
<h3><a class="header" href="#concurrency" id="concurrency">Concurrency</a></h3>
<ul>
<li><strong><a href="https://stjepang.github.io/2019/01/29/lock-free-rust-crossbeam-in-2019.html">Lock-free Rust: Crossbeam in 2019</a></strong> a high-level overview of concurrency in Rust.</li>
<li><strong><a href="https://github.com/rayon-rs/rayon">Rayon</a></strong> splits your data into distinct pieces, gives each piece to a thread to do some kind of computation on it, and finally aggregates results. Its goal is to distribute CPU-intensive tasks onto a thread pool.</li>
<li><strong><a href="https://github.com/tokio-rs/tokio">Tokio</a></strong> runs tasks which sometimes need to be paused in order to wait for asynchronous events. Handling tons of such tasks is no problem. Its goal is to distribute IO-intensive tasks onto a thread pool.</li>
<li><strong><a href="https://github.com/crossbeam-rs/crossbeam">Crossbeam</a></strong> is all about low-level concurrency: atomics, concurrent data structures, synchronization primitives. Same idea as the <code>std::sync</code> module, but bigger. Its goal is to provide tools on top of which libraries like Rayon and Tokio can be built.</li>
</ul>
<h3><a class="header" href="#asynchrony" id="asynchrony">Asynchrony</a></h3>
<p><a href="https://areweasyncyet.rs/">Are we <code>async</code> yet?</a></p>
<p><strong>Conceptual</strong></p>
<ul>
<li><a href="https://boats.gitlab.io/blog/post/wakers-i/">Introduction to Async/Await Programming (withoutboats/wakers-i)</a></li>
<li><a href="https://aturon.github.io/tech/2016/08/11/futures/">Futures (by Aaron Turon)</a></li>
<li><a href="https://www.youtube.com/watch?v=skos4B5x7qE">RustLatam 2019 - Without Boats: Zero-Cost Async IO</a></li>
</ul>
<p><strong>Projects</strong></p>
<ul>
<li><a href="https://github.com/rustasync">Rust Asynchronous Ecosystem Working Group</a></li>
<li><a href="https://github.com/withoutboats/romio">romio</a></li>
<li><a href="https://tokio.rs/docs/overview/">Tokio Docs</a></li>
</ul>
<h3><a class="header" href="#concurrency-1" id="concurrency-1">Concurrency</a></h3>
<p><strong>Conceptual</strong></p>
<ul>
<li><a href="https://stjepang.github.io/2019/01/29/lock-free-rust-crossbeam-in-2019.html">Lock-free Rust: Crossbeam in 2019</a></li>
<li><a href="https://github.com/crossbeam-rs/rfcs/wiki">Crossbeam Research Meta-link</a></li>
<li><a href="https://www.youtube.com/watch?v=Dbytx0ivH7Q">Rust Concurrency Explained</a></li>
</ul>
<p><strong>Projects</strong></p>
<ul>
<li><a href="https://github.com/spacejam/sled">sled</a></li>
<li><a href="https://github.com/servo/servo">servo</a></li>
<li><a href="https://github.com/tikv/tikv">TiKV</a></li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        

        

        
        
        
        <script type="text/javascript">
            window.playpen_copyable = true;
        </script>
        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        
        <script type="text/javascript" src=".analytics/load.js"></script>
        
        <script type="text/javascript" src=".analytics/config.js"></script>
        
        <script type="text/javascript" src=".analytics/klaro.min.js"></script>
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
        
        

    </body>
</html>
